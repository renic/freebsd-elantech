Index: sys/dev/atkbdc/atkbd.c
===================================================================
--- sys/dev/atkbdc/atkbd.c	(revision 292841)
+++ sys/dev/atkbdc/atkbd.c	(working copy)
@@ -49,9 +49,26 @@
 #include <dev/atkbdc/atkbdreg.h>
 #include <dev/atkbdc/atkbdcreg.h>
 
-static timeout_t	atkbd_timeout;
+typedef struct atkbd_state {
+	KBDC		kbdc;		/* keyboard controller */
+	int		ks_mode;	/* input mode (K_XLATE,K_RAW,K_CODE) */
+	int		ks_flags;	/* flags */
+#define COMPOSE		(1 << 0)
+	int		ks_polling;
+	int		ks_state;	/* shift/lock key state */
+	int		ks_accents;	/* accent key index (> 0) */
+	u_int		ks_composed_char; /* composed char code (> 0) */
+	u_char		ks_prefix;	/* AT scan code prefix */
+	struct callout	ks_timer;
+} atkbd_state_t;
+
+static void		atkbd_timeout(void *arg);
 static void		atkbd_shutdown_final(void *v);
+static int		atkbd_reset(KBDC kbdc, int flags, int c);
 
+#define HAS_QUIRK(p, q)		(((atkbdc_softc_t *)(p))->quirks & q)
+#define ALLOW_DISABLE_KBD(kbdc)	!HAS_QUIRK(kbdc, KBDC_QUIRK_KEEP_ACTIVATED)
+
 #define DEFAULT_DELAY		0x1  /* 500ms */
 #define DEFAULT_RATE		0x10 /* 14Hz */
 
@@ -78,6 +95,7 @@
 atkbd_attach_unit(device_t dev, keyboard_t **kbd, int irq, int flags)
 {
 	keyboard_switch_t *sw;
+	atkbd_state_t *state;
 	int args[2];
 	int error;
 	int unit;
@@ -110,6 +128,8 @@
 	 * This is a kludge to compensate for lost keyboard interrupts.
 	 * A similar code used to be in syscons. See below. XXX
 	 */
+	state = (atkbd_state_t *)(*kbd)->kb_data;
+	callout_init(&state->ks_timer, 0);
 	atkbd_timeout(*kbd);
 
 	if (bootverbose)
@@ -124,6 +144,7 @@
 static void
 atkbd_timeout(void *arg)
 {
+	atkbd_state_t *state;
 	keyboard_t *kbd;
 	int s;
 
@@ -165,7 +186,8 @@
 			kbdd_intr(kbd, NULL);
 	}
 	splx(s);
-	timeout(atkbd_timeout, arg, hz/10);
+	state = (atkbd_state_t *)kbd->kb_data;
+	callout_reset(&state->ks_timer, hz / 10, atkbd_timeout, arg);
 }
 
 /* LOW-LEVEL */
@@ -172,18 +194,6 @@
 
 #define ATKBD_DEFAULT	0
 
-typedef struct atkbd_state {
-	KBDC		kbdc;		/* keyboard controller */
-	int		ks_mode;	/* input mode (K_XLATE,K_RAW,K_CODE) */
-	int		ks_flags;	/* flags */
-#define COMPOSE		(1 << 0)
-	int		ks_polling;
-	int		ks_state;	/* shift/lock key state */
-	int		ks_accents;	/* accent key index (> 0) */
-	u_int		ks_composed_char; /* composed char code (> 0) */
-	u_char		ks_prefix;	/* AT scan code prefix */
-} atkbd_state_t;
-
 /* keyboard driver declaration */
 static int		atkbd_configure(int flags);
 static kbd_probe_t	atkbd_probe;
@@ -460,7 +470,10 @@
 static int
 atkbd_term(keyboard_t *kbd)
 {
+	atkbd_state_t *state = (atkbd_state_t *)kbd->kb_data;
+
 	kbd_unregister(kbd);
+	callout_drain(&state->ks_timer);
 	return 0;
 }
 
@@ -1076,6 +1089,39 @@
 #endif
 }
 
+static int
+atkbd_reset(KBDC kbdc, int flags, int c)
+{
+	/* reset keyboard hardware */
+	if (!(flags & KB_CONF_NO_RESET) && !reset_kbd(kbdc)) {
+		/*
+		 * KEYBOARD ERROR
+		 * Keyboard reset may fail either because the keyboard
+		 * doen't exist, or because the keyboard doesn't pass
+		 * the self-test, or the keyboard controller on the
+		 * motherboard and the keyboard somehow fail to shake hands.
+		 * It is just possible, particularly in the last case,
+		 * that the keyboard controller may be left in a hung state.
+		 * test_controller() and test_kbd_port() appear to bring
+		 * the keyboard controller back (I don't know why and how,
+		 * though.)
+		 */
+		empty_both_buffers(kbdc, 10);
+		test_controller(kbdc);
+		test_kbd_port(kbdc);
+		/*
+		 * We could disable the keyboard port and interrupt... but, 
+		 * the keyboard may still exist (see above). 
+		 */
+		set_controller_command_byte(kbdc,
+		    ALLOW_DISABLE_KBD(kbdc) ? 0xff : KBD_KBD_CONTROL_BITS, c);
+		if (bootverbose)
+			printf("atkbd: failed to reset the keyboard.\n");
+		return (EIO);
+	}
+	return (0);
+}
+
 /* local functions */
 
 static int
@@ -1193,13 +1239,14 @@
 		kbdc_set_device_mask(kbdc, m | KBD_KBD_CONTROL_BITS);
 	} else {
 		/* try to restore the command byte as before */
-		set_controller_command_byte(kbdc, 0xff, c);
+		set_controller_command_byte(kbdc,
+		    ALLOW_DISABLE_KBD(kbdc) ? 0xff : KBD_KBD_CONTROL_BITS, c);
 		kbdc_set_device_mask(kbdc, m);
 	}
 #endif
 
 	kbdc_lock(kbdc, FALSE);
-	return err;
+	return (HAS_QUIRK(kbdc, KBDC_QUIRK_IGNORE_PROBE_RESULT) ? 0 : err);
 }
 
 static int
@@ -1242,6 +1289,12 @@
 		return EIO;
 	}
 
+	if (HAS_QUIRK(kbdc, KBDC_QUIRK_RESET_AFTER_PROBE) &&
+	    atkbd_reset(kbdc, flags, c)) {
+		kbdc_lock(kbdc, FALSE);
+		return EIO;
+	}
+
 	/* 
 	 * Check if we have an XT keyboard before we attempt to reset it. 
 	 * The procedure assumes that the keyboard and the controller have 
@@ -1286,31 +1339,9 @@
 	if (bootverbose)
 		printf("atkbd: keyboard ID 0x%x (%d)\n", id, *type);
 
-	/* reset keyboard hardware */
-	if (!(flags & KB_CONF_NO_RESET) && !reset_kbd(kbdc)) {
-		/*
-		 * KEYBOARD ERROR
-		 * Keyboard reset may fail either because the keyboard
-		 * doen't exist, or because the keyboard doesn't pass
-		 * the self-test, or the keyboard controller on the
-		 * motherboard and the keyboard somehow fail to shake hands.
-		 * It is just possible, particularly in the last case,
-		 * that the keyboard controller may be left in a hung state.
-		 * test_controller() and test_kbd_port() appear to bring
-		 * the keyboard controller back (I don't know why and how,
-		 * though.)
-		 */
-		empty_both_buffers(kbdc, 10);
-		test_controller(kbdc);
-		test_kbd_port(kbdc);
-		/*
-		 * We could disable the keyboard port and interrupt... but, 
-		 * the keyboard may still exist (see above). 
-		 */
-		set_controller_command_byte(kbdc, 0xff, c);
+	if (!HAS_QUIRK(kbdc, KBDC_QUIRK_RESET_AFTER_PROBE) &&
+	    atkbd_reset(kbdc, flags, c)) {
 		kbdc_lock(kbdc, FALSE);
-		if (bootverbose)
-			printf("atkbd: failed to reset the keyboard.\n");
 		return EIO;
 	}
 
@@ -1330,7 +1361,8 @@
 			 * The XT kbd isn't usable unless the proper scan
 			 * code set is selected. 
 			 */
-			set_controller_command_byte(kbdc, 0xff, c);
+			set_controller_command_byte(kbdc, ALLOW_DISABLE_KBD(kbdc)
+			    ? 0xff : KBD_KBD_CONTROL_BITS, c);
 			kbdc_lock(kbdc, FALSE);
 			printf("atkbd: unable to set the XT keyboard mode.\n");
 			return EIO;
@@ -1345,6 +1377,17 @@
 	c |= KBD_TRANSLATION;
 #endif
 
+	/*
+	 * Some keyboards require a SETLEDS command to be sent after
+	 * the reset command before they will send keystrokes to us
+	 */
+	if (HAS_QUIRK(kbdc, KBDC_QUIRK_SETLEDS_ON_INIT) &&
+	    send_kbd_command_and_data(kbdc, KBDC_SET_LEDS, 0) != KBD_ACK) {
+		printf("atkbd: setleds failed\n");
+	}
+	if (!ALLOW_DISABLE_KBD(kbdc))
+	    send_kbd_command(kbdc, KBDC_ENABLE_KBD);
+
 	/* enable the keyboard port and intr. */
 	if (!set_controller_command_byte(kbdc, 
 		KBD_KBD_CONTROL_BITS | KBD_TRANSLATION | KBD_OVERRIDE_KBD_LOCK,
@@ -1355,7 +1398,9 @@
 		 * This is serious; we are left with the disabled
 		 * keyboard intr. 
 		 */
-		set_controller_command_byte(kbdc, 0xff, c);
+		set_controller_command_byte(kbdc, ALLOW_DISABLE_KBD(kbdc)
+		    ? 0xff : (KBD_KBD_CONTROL_BITS | KBD_TRANSLATION |
+			KBD_OVERRIDE_KBD_LOCK), c);
 		kbdc_lock(kbdc, FALSE);
 		printf("atkbd: unable to enable the keyboard port and intr.\n");
 		return EIO;
Index: sys/dev/atkbdc/atkbdc.c
===================================================================
--- sys/dev/atkbdc/atkbdc.c	(revision 292841)
+++ sys/dev/atkbdc/atkbdc.c	(working copy)
@@ -114,6 +114,41 @@
 static int wait_for_aux_data(atkbdc_softc_t *kbdc);
 static int wait_for_aux_ack(atkbdc_softc_t *kbdc);
 
+struct atkbdc_quirks {
+    const char* bios_vendor;
+    const char*	maker;
+    const char*	product;
+    int		quirk;
+};
+
+static struct atkbdc_quirks quirks[] = {
+    {"coreboot", "Acer", "Peppy",
+	KBDC_QUIRK_KEEP_ACTIVATED | KBDC_QUIRK_IGNORE_PROBE_RESULT |
+	KBDC_QUIRK_RESET_AFTER_PROBE | KBDC_QUIRK_SETLEDS_ON_INIT},
+
+    {NULL, NULL, NULL, 0}
+};
+
+#define QUIRK_STR_MATCH(s1, s2) (s1 == NULL || \
+    (s2 != NULL && !strcmp(s1, s2)))
+
+static int
+atkbdc_getquirks(void)
+{
+    int i;
+    char* bios_vendor = getenv("smbios.bios.vendor");
+    char* maker = getenv("smbios.system.maker");
+    char* product = getenv("smbios.system.product");
+
+    for (i=0; quirks[i].quirk != 0; ++i)
+	if (QUIRK_STR_MATCH(quirks[i].bios_vendor, bios_vendor) &&
+	    QUIRK_STR_MATCH(quirks[i].maker, maker) &&
+	    QUIRK_STR_MATCH(quirks[i].product, product))
+		return (quirks[i].quirk);
+
+    return (0);
+}
+
 atkbdc_softc_t
 *atkbdc_get_softc(int unit)
 {
@@ -176,8 +211,6 @@
 	/* XXX: tag should be passed from the caller */
 #if defined(__amd64__) || defined(__i386__)
 	tag = X86_BUS_SPACE_IO;
-#elif defined(__ia64__)
-	tag = IA64_BUS_SPACE_IO;
 #elif defined(__sparc64__)
 	tag = &atkbdc_bst_store[0];
 #else
@@ -297,6 +330,7 @@
 #else
 	sc->retry = 5000;
 #endif
+	sc->quirks = atkbdc_getquirks();
 
 	return 0;
 }
@@ -1126,7 +1160,8 @@
 kbdc_set_device_mask(KBDC p, int mask)
 {
     kbdcp(p)->command_mask = 
-	mask & (KBD_KBD_CONTROL_BITS | KBD_AUX_CONTROL_BITS);
+	mask & (((kbdcp(p)->quirks & KBDC_QUIRK_KEEP_ACTIVATED)
+	    ? 0 : KBD_KBD_CONTROL_BITS) | KBD_AUX_CONTROL_BITS);
 }
 
 int
Index: sys/dev/atkbdc/atkbdcreg.h
===================================================================
--- sys/dev/atkbdc/atkbdcreg.h	(revision 292841)
+++ sys/dev/atkbdc/atkbdcreg.h	(working copy)
@@ -202,6 +202,11 @@
     kqueue kbd;			/* keyboard data queue */
     kqueue aux;			/* auxiliary data queue */
     int retry;
+    int quirks;			/* controller doesn't like deactivate */
+#define KBDC_QUIRK_KEEP_ACTIVATED	(1 << 0)
+#define KBDC_QUIRK_IGNORE_PROBE_RESULT	(1 << 1)
+#define KBDC_QUIRK_RESET_AFTER_PROBE	(1 << 2)
+#define KBDC_QUIRK_SETLEDS_ON_INIT	(1 << 3)
 } atkbdc_softc_t; 
 
 enum kbdc_device_ivar {
Index: sys/dev/atkbdc/psm.c
===================================================================
--- sys/dev/atkbdc/psm.c	(revision 292841)
+++ sys/dev/atkbdc/psm.c	(working copy)
@@ -81,6 +81,7 @@
 #include <sys/sysctl.h>
 #include <sys/time.h>
 #include <sys/uio.h>
+#include <sys/libkern.h>
 
 #include <sys/limits.h>
 #include <sys/mouse.h>
@@ -161,40 +162,6 @@
 #define	PSM_PACKETQUEUE	128
 #endif
 
-enum {
-	SYNAPTICS_SYSCTL_MIN_PRESSURE,
-	SYNAPTICS_SYSCTL_MAX_PRESSURE,
-	SYNAPTICS_SYSCTL_MAX_WIDTH,
-	SYNAPTICS_SYSCTL_MARGIN_TOP,
-	SYNAPTICS_SYSCTL_MARGIN_RIGHT,
-	SYNAPTICS_SYSCTL_MARGIN_BOTTOM,
-	SYNAPTICS_SYSCTL_MARGIN_LEFT,
-	SYNAPTICS_SYSCTL_NA_TOP,
-	SYNAPTICS_SYSCTL_NA_RIGHT,
-	SYNAPTICS_SYSCTL_NA_BOTTOM,
-	SYNAPTICS_SYSCTL_NA_LEFT,
-	SYNAPTICS_SYSCTL_WINDOW_MIN,
-	SYNAPTICS_SYSCTL_WINDOW_MAX,
-	SYNAPTICS_SYSCTL_MULTIPLICATOR,
-	SYNAPTICS_SYSCTL_WEIGHT_CURRENT,
-	SYNAPTICS_SYSCTL_WEIGHT_PREVIOUS,
-	SYNAPTICS_SYSCTL_WEIGHT_PREVIOUS_NA,
-	SYNAPTICS_SYSCTL_WEIGHT_LEN_SQUARED,
-	SYNAPTICS_SYSCTL_DIV_MIN,
-	SYNAPTICS_SYSCTL_DIV_MAX,
-	SYNAPTICS_SYSCTL_DIV_MAX_NA,
-	SYNAPTICS_SYSCTL_DIV_LEN,
-	SYNAPTICS_SYSCTL_TAP_MAX_DELTA,
-	SYNAPTICS_SYSCTL_TAP_MIN_QUEUE,
-	SYNAPTICS_SYSCTL_TAPHOLD_TIMEOUT,
-	SYNAPTICS_SYSCTL_VSCROLL_HOR_AREA,
-	SYNAPTICS_SYSCTL_VSCROLL_VER_AREA,
-	SYNAPTICS_SYSCTL_VSCROLL_MIN_DELTA,
-	SYNAPTICS_SYSCTL_VSCROLL_DIV_MIN,
-	SYNAPTICS_SYSCTL_VSCROLL_DIV_MAX,
-	SYNAPTICS_SYSCTL_TOUCHPAD_OFF
-};
-
 typedef struct synapticsinfo {
 	struct sysctl_ctx_list	 sysctl_ctx;
 	struct sysctl_oid	*sysctl_tree;
@@ -231,6 +198,11 @@
 	int			 vscroll_div_min;
 	int			 vscroll_div_max;
 	int			 touchpad_off;
+	int			 softbuttons;
+	int			 softbuttons_y;
+	int			 softbutton2_x;
+	int			 softbutton3_x;
+	int			 softbutton_nomove;
 } synapticsinfo_t;
 
 typedef struct synapticspacket {
@@ -295,6 +267,97 @@
 	int	skipback;
 } trackpointinfo_t;
 
+typedef struct finger {
+	int			x;
+	int			y;
+	int			p;
+	int			w;
+	int			flags;
+} finger_t;
+#define	PSM_GESTURE_FINGERS	2
+#define	PSM_FINGER_IS_PEN	(1<<0)
+#define	PSM_FINGER_FUZZY	(1<<1)
+#define	PSM_FINGER_IS_SET(f) ((f).x != -1 && (f).y != -1 && (f).p != 0)
+#define	PSM_FINGER_RESET(f) do \
+	(f) = (finger_t) { .x = -1, .y = -1, .p = 0, .w = 0, .flags = 0 }; \
+while (0)
+
+typedef struct elantechhw {
+	int			hwversion;
+	int			fwversion;
+	int			sizex;
+	int			sizey;
+	int			dpix;
+	int			dpiy;
+	int			ntracesx;
+	int			ntracesy;
+	int			isclickpad;
+	int			hascrc;
+	int			hastrackpad;
+	int			haspressure;
+} elantechhw_t;
+
+/* minimum versions supported by this driver */
+#define	ELANTECH_HW_IS_V1(fwver) ((fwver) < 0x020030 || (fwver) == 0x020600)
+
+#define	ELANTECH_MAGIC(magic)				\
+	((magic)[0] == 0x3c && (magic)[1] == 0x03 &&	\
+	((magic)[2] == 0xc8 || (magic)[2] == 0x00))
+
+#define	ELANTECH_FW_ID		0x00
+#define	ELANTECH_FW_VERSION	0x01
+#define	ELANTECH_CAPABILITIES	0x02
+#define	ELANTECH_SAMPLE		0x03
+#define	ELANTECH_RESOLUTION	0x04
+#define	ELANTECH_REG_READ	0x10
+#define	ELANTECH_REG_WRITE	0x11
+#define	ELANTECH_REG_RDWR	0x00
+#define	ELANTECH_CUSTOM_CMD	0xf8
+
+#define	ELANTECH_FINGER_DEFAULT_P tap_threshold
+#define	ELANTECH_FINGER_DEFAULT_W 1
+#define	ELANTECH_FINGER_SET_XYP(pb) (finger_t) {			\
+    .x = (((pb)->ipacket[1] & 0x0f) << 8) | (pb)->ipacket[2],		\
+    .y = (((pb)->ipacket[4] & 0x0f) << 8) | (pb)->ipacket[5],		\
+    .p = ((pb)->ipacket[1] & 0xf0) | (((pb)->ipacket[4] >> 4) & 0x0f),	\
+    .w = ELANTECH_FINGER_DEFAULT_W,					\
+    .flags = 0								\
+}
+
+enum {
+	ELANTECH_PKT_NOP,
+	ELANTECH_PKT_TRACKPOINT,
+	ELANTECH_PKT_V2_COMMON,
+	ELANTECH_PKT_V2_2FINGER,
+	ELANTECH_PKT_V3,
+	ELANTECH_PKT_V4_STATUS,
+	ELANTECH_PKT_V4_HEAD,
+	ELANTECH_PKT_V4_MOTION
+};
+
+#define	ELANTECH_PKT_IS_TRACKPOINT(pb) (((pb)->ipacket[3] & 0x0f) == 0x06)
+#define	ELANTECH_PKT_IS_DEBOUNCE(pb, hwversion) ((hwversion) == 4 ? 0 :	\
+    (pb)->ipacket[0] == ((hwversion) == 2 ? 0x84 : 0xc4) &&		\
+    (pb)->ipacket[1] == 0xff && (pb)->ipacket[2] == 0xff &&		\
+    (pb)->ipacket[3] == 0x02 && (pb)->ipacket[4] == 0xff &&		\
+    (pb)->ipacket[5] == 0xff)
+#define	ELANTECH_PKT_IS_V2(pb) 						\
+    (((pb)->ipacket[0] & 0x0c) == 0x04 && ((pb)->ipacket[3] & 0x0f) == 0x02)
+#define	ELANTECH_PKT_IS_V3_HEAD(pb, hascrc) ((hascrc) ? 		\
+    ((pb)->ipacket[3] & 0x09) == 0x08 : 				\
+    ((pb)->ipacket[0] & 0x0c) == 0x04 && ((pb)->ipacket[3] & 0xcf) == 0x02)
+#define	ELANTECH_PKT_IS_V3_TAIL(pb, hascrc) ((hascrc) ? 		\
+    ((pb)->ipacket[3] & 0x09) == 0x09 : 				\
+    ((pb)->ipacket[0] & 0x0c) == 0x0c && ((pb)->ipacket[3] & 0xce) == 0x0c)
+#define	ELANTECH_PKT_IS_V4(pb, hascrc) ((hascrc) ? 			\
+    ((pb)->ipacket[3] & 0x08) == 0x00 :					\
+    ((pb)->ipacket[0] & 0x0c) == 0x04 && ((pb)->ipacket[3] & 0x1c) == 0x10)
+
+typedef struct elantechaction {
+	finger_t		fingers[PSM_GESTURE_FINGERS];
+	int			nfingers;
+} elantechaction_t;
+
 /* driver control block */
 struct psm_softc {		/* Driver status information */
 	int		unit;
@@ -308,7 +371,10 @@
 	mousehw_t	hw;		/* hardware information */
 	synapticshw_t	synhw;		/* Synaptics hardware information */
 	synapticsinfo_t	syninfo;	/* Synaptics configuration */
-	synapticsaction_t synaction;	/* Synaptics action context */
+	synapticsaction_t
+	    synaction[PSM_GESTURE_FINGERS]; /* Synaptics action context */
+	elantechhw_t	elanhw;		/* Elantech hardware information */
+	elantechaction_t elanaction;	/* Elantech action context */
 	int		tphw;		/* TrackPoint hardware information */
 	trackpointinfo_t tpinfo;	/* TrackPoint configuration */
 	mousemode_t	mode;		/* operation mode */
@@ -331,6 +397,8 @@
 	struct timeval	lastsoftintr;	/* time of last soft interrupt */
 	struct timeval	lastinputerr;	/* time last sync error happened */
 	struct timeval	taptimeout;	/* tap timeout for touchpads */
+	struct timeval	idletimeout;
+	packetbuf_t	idlepacket;	/* packet to send after idle timeout */
 	int		watchdog;	/* watchdog timer flag */
 	struct callout	callout;	/* watchdog timer call out */
 	struct callout	softcallout; /* buffer timer call out */
@@ -375,6 +443,10 @@
 /* other flags (flags) */
 #define	PSM_FLAGS_FINGERDOWN	0x0001	/* VersaPad finger down */
 
+#define kbdcp(p)			((atkbdc_softc_t *)(p))
+#define ALWAYS_RESTORE_CONTROLLER(kbdc)	!(kbdcp(kbdc)->quirks \
+    & KBDC_QUIRK_KEEP_ACTIVATED)
+
 /* Tunables */
 static int tap_enabled = -1;
 TUNABLE_INT("hw.psm.tap_enabled", &tap_enabled);
@@ -385,6 +457,9 @@
 static int trackpoint_support = 0;
 TUNABLE_INT("hw.psm.trackpoint_support", &trackpoint_support);
 
+static int elantech_support = 0;
+TUNABLE_INT("hw.psm.elantech_support", &elantech_support);
+
 static int verbose = PSM_DEBUG;
 TUNABLE_INT("debug.psm.loglevel", &verbose);
 
@@ -407,6 +482,46 @@
 	int	accelfactor;
 } old_mousemode_t;
 
+#define SYN_OFFSET(field) offsetof(struct psm_softc, syninfo.field)
+enum {
+	SYNAPTICS_SYSCTL_MIN_PRESSURE =		SYN_OFFSET(min_pressure),
+	SYNAPTICS_SYSCTL_MAX_PRESSURE =		SYN_OFFSET(max_pressure),
+	SYNAPTICS_SYSCTL_MAX_WIDTH =		SYN_OFFSET(max_width),
+	SYNAPTICS_SYSCTL_MARGIN_TOP =		SYN_OFFSET(margin_top),
+	SYNAPTICS_SYSCTL_MARGIN_RIGHT =		SYN_OFFSET(margin_right),
+	SYNAPTICS_SYSCTL_MARGIN_BOTTOM =	SYN_OFFSET(margin_bottom),
+	SYNAPTICS_SYSCTL_MARGIN_LEFT =		SYN_OFFSET(margin_left),
+	SYNAPTICS_SYSCTL_NA_TOP =		SYN_OFFSET(na_top),
+	SYNAPTICS_SYSCTL_NA_RIGHT =		SYN_OFFSET(na_right),
+	SYNAPTICS_SYSCTL_NA_BOTTOM =		SYN_OFFSET(na_bottom),
+	SYNAPTICS_SYSCTL_NA_LEFT = 		SYN_OFFSET(na_left),
+	SYNAPTICS_SYSCTL_WINDOW_MIN =		SYN_OFFSET(window_min),
+	SYNAPTICS_SYSCTL_WINDOW_MAX =		SYN_OFFSET(window_max),
+	SYNAPTICS_SYSCTL_MULTIPLICATOR =	SYN_OFFSET(multiplicator),
+	SYNAPTICS_SYSCTL_WEIGHT_CURRENT =	SYN_OFFSET(weight_current),
+	SYNAPTICS_SYSCTL_WEIGHT_PREVIOUS =	SYN_OFFSET(weight_previous),
+	SYNAPTICS_SYSCTL_WEIGHT_PREVIOUS_NA =	SYN_OFFSET(weight_previous_na),
+	SYNAPTICS_SYSCTL_WEIGHT_LEN_SQUARED =	SYN_OFFSET(weight_len_squared),
+	SYNAPTICS_SYSCTL_DIV_MIN =		SYN_OFFSET(div_min),
+	SYNAPTICS_SYSCTL_DIV_MAX =		SYN_OFFSET(div_max),
+	SYNAPTICS_SYSCTL_DIV_MAX_NA =		SYN_OFFSET(div_max_na),
+	SYNAPTICS_SYSCTL_DIV_LEN =		SYN_OFFSET(div_len),
+	SYNAPTICS_SYSCTL_TAP_MAX_DELTA =	SYN_OFFSET(tap_max_delta),
+	SYNAPTICS_SYSCTL_TAP_MIN_QUEUE =	SYN_OFFSET(tap_min_queue),
+	SYNAPTICS_SYSCTL_TAPHOLD_TIMEOUT =	SYN_OFFSET(taphold_timeout),
+	SYNAPTICS_SYSCTL_VSCROLL_HOR_AREA =	SYN_OFFSET(vscroll_hor_area),
+	SYNAPTICS_SYSCTL_VSCROLL_VER_AREA =	SYN_OFFSET(vscroll_ver_area),
+	SYNAPTICS_SYSCTL_VSCROLL_MIN_DELTA =	SYN_OFFSET(vscroll_min_delta),
+	SYNAPTICS_SYSCTL_VSCROLL_DIV_MIN =	SYN_OFFSET(vscroll_div_min),
+	SYNAPTICS_SYSCTL_VSCROLL_DIV_MAX =	SYN_OFFSET(vscroll_div_max),
+	SYNAPTICS_SYSCTL_TOUCHPAD_OFF =		SYN_OFFSET(touchpad_off),
+	SYNAPTICS_SYSCTL_SOFTBUTTONS =		SYN_OFFSET(softbuttons),
+	SYNAPTICS_SYSCTL_SOFTBUTTONS_Y =	SYN_OFFSET(softbuttons_y),
+	SYNAPTICS_SYSCTL_SOFTBUTTON2_X =	SYN_OFFSET(softbutton2_x),
+	SYNAPTICS_SYSCTL_SOFTBUTTON3_X =	SYN_OFFSET(softbutton3_x),
+	SYNAPTICS_SYSCTL_SOFTBUTTON_NOMOVE =	SYN_OFFSET(softbutton_nomove)
+};
+
 /* packet formatting function */
 typedef int	packetfunc_t(struct psm_softc *, u_char *, int *, int,
     mousestatus_t *);
@@ -442,6 +557,7 @@
 static int	reinitialize(struct psm_softc *, int);
 static char	*model_name(int);
 static void	psmsoftintr(void *);
+static void	psmsoftintridle(void *);
 static void	psmintr(void *);
 static void	psmtimeout(void *);
 static int	timeelapsed(const struct timeval *, int, int,
@@ -454,11 +570,17 @@
 		    mousestatus_t *, int *, int *, int *);
 static void	proc_versapad(struct psm_softc *, packetbuf_t *,
 		    mousestatus_t *, int *, int *, int *);
+static int	proc_elantech(struct psm_softc *, packetbuf_t *,
+		    mousestatus_t *, int *, int *, int *);
+static void	psmgestures(struct psm_softc *, synapticsaction_t *, finger_t,
+		    int, mousestatus_t *, int *, int *);
+static int	psmsoftbuttons(struct psm_softc *, finger_t, int);
 static int	tame_mouse(struct psm_softc *, packetbuf_t *, mousestatus_t *,
 		    u_char *);
 
 /* vendor specific features */
-typedef int	probefunc_t(KBDC, struct psm_softc *);
+enum probearg { PROBE, REINIT };
+typedef int	probefunc_t(struct psm_softc *, enum probearg);
 
 static int	mouse_id_proc1(KBDC, int, int, int *);
 static int	mouse_ext_command(KBDC, int);
@@ -475,10 +597,13 @@
 static probefunc_t	enable_synaptics;
 static probefunc_t	enable_trackpoint;
 static probefunc_t	enable_versapad;
+static probefunc_t	enable_elantech;
 
 static void set_trackpoint_parameters(struct psm_softc *sc);
 static void synaptics_passthrough_on(struct psm_softc *sc);
 static void synaptics_passthrough_off(struct psm_softc *sc);
+static int synaptics_preferred_mode(struct psm_softc *sc);
+static void synaptics_set_mode(struct psm_softc *sc, int mode_byte);
 
 static struct {
 	int		model;
@@ -504,6 +629,8 @@
 	  0xc8, MOUSE_4DPLUS_PACKETSIZE, enable_4dplus },
 	{ MOUSE_MODEL_SYNAPTICS,	/* Synaptics Touchpad */
 	  0xc0, MOUSE_SYNAPTICS_PACKETSIZE, enable_synaptics },
+	{ MOUSE_MODEL_ELANTECH,		/* Elantech Touchpad */
+	  0x04, MOUSE_ELANTECH_PACKETSIZE, enable_elantech },
 	{ MOUSE_MODEL_INTELLI,		/* Microsoft IntelliMouse */
 	  0x08, MOUSE_PS2INTELLI_PACKETSIZE, enable_msintelli },
 	{ MOUSE_MODEL_GLIDEPOINT,	/* ALPS GlidePoint */
@@ -756,6 +883,7 @@
 		{ MOUSE_MODEL_4DPLUS,		"4D+ Mouse" },
 		{ MOUSE_MODEL_SYNAPTICS,	"Synaptics Touchpad" },
 		{ MOUSE_MODEL_TRACKPOINT,	"IBM/Lenovo TrackPoint" },
+		{ MOUSE_MODEL_ELANTECH,		"Elantech Touchpad" },
 		{ MOUSE_MODEL_GENERIC,		"Generic PS/2 mouse" },
 		{ MOUSE_MODEL_UNKNOWN,		"Unknown" },
 	};
@@ -876,7 +1004,7 @@
 	/* Re-enable the mouse. */
 	for (i = 0; vendortype[i].probefunc != NULL; ++i)
 		if (vendortype[i].model == sc->hw.model)
-			(*vendortype[i].probefunc)(sc->kbdc, NULL);
+			(*vendortype[i].probefunc)(sc, REINIT);
 
 	/* set mouse parameters */
 	if (mode != (mousemode_t *)NULL) {
@@ -887,13 +1015,6 @@
 			    set_mouse_resolution(kbdc, mode->resolution);
 		set_mouse_scaling(kbdc, 1);
 		set_mouse_mode(kbdc);
-
-		/*
-		 * Trackpoint settings are lost on resume.
-		 * Restore them here.
-		 */
-		if (sc->tphw > 0)
-			set_trackpoint_parameters(sc);
 	}
 
 	/* Record sync on the next data packet we see. */
@@ -929,14 +1050,8 @@
 		get_mouse_status(sc->kbdc, stat, 0, 3);
 		if ((SYNAPTICS_VERSION_GE(sc->synhw, 7, 5) ||
 		     stat[1] == 0x47) &&
-		    stat[2] == 0x40) {
-			/* Set the mode byte -- request wmode where
-			 * available */
-			if (sc->synhw.capExtended)
-				mouse_ext_command(sc->kbdc, 0xc1);
-			else
-				mouse_ext_command(sc->kbdc, 0xc0);
-			set_mouse_sampling_rate(sc->kbdc, 20);
+		     stat[2] == 0x40) {
+			synaptics_set_mode(sc, synaptics_preferred_mode(sc));
 			VLOG(5, (LOG_DEBUG, "psm%d: Synaptis Absolute Mode "
 			    "hopefully restored\n",
 			    sc->unit));
@@ -1246,7 +1361,8 @@
 		 * this is CONTROLLER ERROR; I don't know how to recover
 		 * from this error...
 		 */
-		restore_controller(sc->kbdc, command_byte);
+		if (ALWAYS_RESTORE_CONTROLLER(sc->kbdc))
+			restore_controller(sc->kbdc, command_byte);
 		printf("psm%d: unable to set the command byte.\n", unit);
 		endprobe(ENXIO);
 	}
@@ -1285,7 +1401,8 @@
 		recover_from_error(sc->kbdc);
 		if (sc->config & PSM_CONFIG_IGNPORTERROR)
 			break;
-		restore_controller(sc->kbdc, command_byte);
+		if (ALWAYS_RESTORE_CONTROLLER(sc->kbdc))
+			restore_controller(sc->kbdc, command_byte);
 		if (verbose)
 			printf("psm%d: the aux port is not functioning (%d).\n",
 			    unit, i);
@@ -1308,7 +1425,8 @@
 		 */
 		if (!reset_aux_dev(sc->kbdc)) {
 			recover_from_error(sc->kbdc);
-			restore_controller(sc->kbdc, command_byte);
+			if (ALWAYS_RESTORE_CONTROLLER(sc->kbdc))
+				restore_controller(sc->kbdc, command_byte);
 			if (verbose)
 				printf("psm%d: failed to reset the aux "
 				    "device.\n", unit);
@@ -1330,7 +1448,8 @@
 	if (!enable_aux_dev(sc->kbdc) || !disable_aux_dev(sc->kbdc)) {
 		/* MOUSE ERROR */
 		recover_from_error(sc->kbdc);
-		restore_controller(sc->kbdc, command_byte);
+		if (ALWAYS_RESTORE_CONTROLLER(sc->kbdc))
+			restore_controller(sc->kbdc, command_byte);
 		if (verbose)
 			printf("psm%d: failed to enable the aux device.\n",
 			    unit);
@@ -1352,7 +1471,8 @@
 	/* verify the device is a mouse */
 	sc->hw.hwid = get_aux_id(sc->kbdc);
 	if (!is_a_mouse(sc->hw.hwid)) {
-		restore_controller(sc->kbdc, command_byte);
+		if (ALWAYS_RESTORE_CONTROLLER(sc->kbdc))
+			restore_controller(sc->kbdc, command_byte);
 		if (verbose)
 			printf("psm%d: unknown device type (%d).\n", unit,
 			    sc->hw.hwid);
@@ -1383,7 +1503,7 @@
 
 		/* other parameters */
 		for (i = 0; vendortype[i].probefunc != NULL; ++i)
-			if ((*vendortype[i].probefunc)(sc->kbdc, sc)) {
+			if ((*vendortype[i].probefunc)(sc, PROBE)) {
 				if (verbose >= 2)
 					printf("psm%d: found %s\n", unit,
 					    model_name(vendortype[i].model));
@@ -1458,7 +1578,8 @@
 		 * this is CONTROLLER ERROR; I don't know the proper way to
 		 * recover from this error...
 		 */
-		restore_controller(sc->kbdc, command_byte);
+		if (ALWAYS_RESTORE_CONTROLLER(sc->kbdc))
+			restore_controller(sc->kbdc, command_byte);
 		printf("psm%d: unable to set the command byte.\n", unit);
 		endprobe(ENXIO);
 	}
@@ -1505,6 +1626,7 @@
 	case MOUSE_MODEL_SYNAPTICS:
 	case MOUSE_MODEL_GLIDEPOINT:
 	case MOUSE_MODEL_VERSAPAD:
+	case MOUSE_MODEL_ELANTECH:
 		sc->config |= PSM_CONFIG_INITAFTERSUSPEND;
 		break;
 	default:
@@ -2166,6 +2288,20 @@
 		    (*(int *)addr > PSM_LEVEL_MAX))
 			return (EINVAL);
 		sc->mode.level = *(int *)addr;
+
+		if (sc->hw.model == MOUSE_MODEL_SYNAPTICS) {
+			/*
+			 * If we are entering PSM_LEVEL_NATIVE, we want to
+			 * enable sending of "extended W mode" packets to
+			 * userland. Reset the mode of the touchpad so that the
+			 * change in the level is picked up.
+			 */
+			error = block_mouse_data(sc, &command_byte);
+			if (error)
+				return (error);
+			synaptics_set_mode(sc, synaptics_preferred_mode(sc));
+			unblock_mouse_data(sc, command_byte);
+		}
 		break;
 
 	case MOUSE_GETSTATUS:
@@ -2614,7 +2750,8 @@
 {
 	static int touchpad_buttons;
 	static int guest_buttons;
-	int w, x0, y0;
+	finger_t f;
+	int w, nfingers;
 
 	/* TouchPad PS/2 absolute mode message format with capFourButtons:
 	 *
@@ -2793,7 +2930,7 @@
 			pb->ipacket[4] &= ~(mask);
 			pb->ipacket[5] &= ~(mask);
 		} else	if (!sc->syninfo.directional_scrolls &&
-		    !sc->synaction.in_vscroll) {
+		    !sc->synaction[0].in_vscroll) {
 			/*
 			 * Keep reporting MOUSE DOWN until we get a new packet
 			 * indicating otherwise.
@@ -2801,19 +2938,73 @@
 			touchpad_buttons |= sc->extended_buttons;
 		}
 	}
+
+	f.x = ((pb->ipacket[3] & 0x10) << 8) |
+	    ((pb->ipacket[1] & 0x0f) << 8) |
+	    pb->ipacket[4];
+	f.y = ((pb->ipacket[3] & 0x20) << 7) |
+	    ((pb->ipacket[1] & 0xf0) << 4) |
+	    pb->ipacket[5];
+	f.p = *z;
+	f.w = w;
+	f.flags |= w == 2 ? PSM_FINGER_IS_PEN : 0;
+	f.flags |= w < 2 ? PSM_FINGER_FUZZY : 0;
+	nfingers = w < 2 ? w + 2 : 1;
+
 	/* Handle ClickPad. */
-	if (sc->synhw.capClickPad &&
-	    ((pb->ipacket[0] ^ pb->ipacket[3]) & 0x01))
-		touchpad_buttons |= MOUSE_BUTTON1DOWN;
+	if (sc->synhw.capClickPad)
+		touchpad_buttons |= psmsoftbuttons(sc, f,
+		    (pb->ipacket[0] ^ pb->ipacket[3]) & 0x01);
 
 	ms->button = touchpad_buttons | guest_buttons;
 
+	psmgestures(sc, &sc->synaction[0], f, nfingers, ms, x, y);
+
+SYNAPTICS_END:
 	/*
+	 * Use the extra buttons as a scrollwheel
+	 *
+	 * XXX X.Org uses the Z axis for vertical wheel only,
+	 * whereas moused(8) understands special values to differ
+	 * vertical and horizontal wheels.
+	 *
+	 * xf86-input-mouse needs therefore a small patch to
+	 * understand these special values. Without it, the
+	 * horizontal wheel acts as a vertical wheel in X.Org.
+	 *
+	 * That's why the horizontal wheel is disabled by
+	 * default for now.
+	 */
+	if (ms->button & MOUSE_BUTTON4DOWN) {
+		*z = -1;
+		ms->button &= ~MOUSE_BUTTON4DOWN;
+	} else if (ms->button & MOUSE_BUTTON5DOWN) {
+		*z = 1;
+		ms->button &= ~MOUSE_BUTTON5DOWN;
+	} else if (ms->button & MOUSE_BUTTON6DOWN) {
+		*z = -2;
+		ms->button &= ~MOUSE_BUTTON6DOWN;
+	} else if (ms->button & MOUSE_BUTTON7DOWN) {
+		*z = 2;
+		ms->button &= ~MOUSE_BUTTON7DOWN;
+	} else
+		*z = 0;
+
+	return (0);
+}
+
+static void
+psmgestures(struct psm_softc *sc, synapticsaction_t *synaction, finger_t f,
+    int nfingers, mousestatus_t *ms, int *x, int *y)
+{
+	*x = *y = 0;
+
+	/*
 	 * Check pressure to detect a real wanted action on the
 	 * touchpad.
 	 */
-	if (*z >= sc->syninfo.min_pressure) {
-		synapticsaction_t *synaction;
+	if (f.p >= sc->syninfo.min_pressure) {
+		int x0, y0;
 		int cursor, peer, window;
 		int dx, dy, dxp, dyp;
 		int max_width, max_pressure;
@@ -2825,8 +3016,10 @@
 		int div_min, div_max, div_len;
 		int vscroll_hor_area, vscroll_ver_area;
 		int two_finger_scroll;
+		int max_x, max_y;
 		int len, weight_prev_x, weight_prev_y;
 		int div_max_x, div_max_y, div_x, div_y;
+		int exiting_scroll;
 
 		/* Read sysctl. */
 		/* XXX Verify values? */
@@ -2852,39 +3045,38 @@
 		vscroll_hor_area = sc->syninfo.vscroll_hor_area;
 		vscroll_ver_area = sc->syninfo.vscroll_ver_area;
 		two_finger_scroll = sc->syninfo.two_finger_scroll;
+		max_x = sc->synhw.maximumXCoord;
+		max_y = sc->synhw.maximumYCoord;
 
+		exiting_scroll = 0;
+
 		/* Palm detection. */
 		if (!(
-		    (sc->synhw.capMultiFinger && (w == 0 || w == 1)) ||
-		    (sc->synhw.capPalmDetect && w >= 4 && w <= max_width) ||
-		    (!sc->synhw.capPalmDetect && *z <= max_pressure) ||
-		    (sc->synhw.capPen && w == 2))) {
+		    ((sc->synhw.capMultiFinger ||
+		      sc->synhw.capAdvancedGestures) && nfingers > 1) ||
+		    (sc->synhw.capPalmDetect && f.w <= max_width) ||
+		    (!sc->synhw.capPalmDetect && f.p <= max_pressure) ||
+		    (sc->synhw.capPen && f.flags & PSM_FINGER_IS_PEN))) {
 			/*
 			 * We consider the packet irrelevant for the current
 			 * action when:
 			 *  - the width isn't comprised in:
-			 *    [4; max_width]
+			 *    [1; max_width]
 			 *  - the pressure isn't comprised in:
 			 *    [min_pressure; max_pressure]
-			 *  - pen aren't supported but w is 2
+			 *  - pen aren't supported but PSM_FiNGER_IS_PEN is set
 			 *
 			 *  Note that this doesn't terminate the current action.
 			 */
 			VLOG(2, (LOG_DEBUG,
-			    "synaptics: palm detected! (%d)\n", w));
-			goto SYNAPTICS_END;
+			    "synaptics: palm detected! (%d)\n", f.w));
+			return;
 		}
 
 		/* Read current absolute position. */
-		x0 = ((pb->ipacket[3] & 0x10) << 8) |
-		    ((pb->ipacket[1] & 0x0f) << 8) |
-		    pb->ipacket[4];
-		y0 = ((pb->ipacket[3] & 0x20) << 7) |
-		    ((pb->ipacket[1] & 0xf0) << 4) |
-		    pb->ipacket[5];
+		x0 = f.x;
+		y0 = f.y;
 
-		synaction = &(sc->synaction);
-
 		/*
 		 * If the action is just beginning, init the structure and
 		 * compute tap timeout.
@@ -2947,15 +3139,15 @@
 		 */
 		if (x0 <= margin_left)
 			x0 = margin_left;
-		else if (x0 >= 6143 - margin_right)
-			x0 = 6143 - margin_right;
+		else if (x0 >= max_x - margin_right)
+			x0 = max_x - margin_right;
 		if (y0 <= margin_bottom)
 			y0 = margin_bottom;
-		else if (y0 >= 6143 - margin_top)
-			y0 = 6143 - margin_top;
+		else if (y0 >= max_y - margin_top)
+			y0 = max_y - margin_top;
 
 		VLOG(3, (LOG_DEBUG, "synaptics: ipacket: [%d, %d], %d, %d\n",
-		    x0, y0, *z, w));
+		    x0, y0, f.p, f.w));
 
 		/* Queue this new packet. */
 		cursor = SYNAPTICS_QUEUE_CURSOR(synaction->queue_cursor - 1);
@@ -2973,26 +3165,18 @@
 		 * pressure peak. Also with multiple fingers, we increase
 		 * the minimum window.
 		 */
-		switch (w) {
-		case 1: /* Three or more fingers. */
-			synaction->fingers_nb = imax(3, synaction->fingers_nb);
+		if (nfingers > 1)
 			synaction->window_min = window_max;
-			break;
-		case 0: /* Two fingers. */
-			synaction->fingers_nb = imax(2, synaction->fingers_nb);
-			synaction->window_min = window_max;
-			break;
-		default: /* One finger or undetectable. */
-			synaction->fingers_nb = imax(1, synaction->fingers_nb);
-		}
-		sc->zmax = imax(*z, sc->zmax);
+		synaction->fingers_nb = imax(nfingers, synaction->fingers_nb);
+		sc->zmax = imax(f.p, sc->zmax);
 
 		/* Do we have enough packets to consider this a movement? */
 		if (synaction->queue_len < synaction->window_min)
-			goto SYNAPTICS_END;
+			return;
 
 		/* Is a scrolling action occuring? */
-		if (!synaction->in_taphold && !synaction->in_vscroll) {
+		if (!synaction->in_taphold &&
+		    (!synaction->in_vscroll || two_finger_scroll)) {
 			/*
 			 * A scrolling action must not conflict with a tap
 			 * action. Here are the conditions to consider a
@@ -3017,7 +3201,7 @@
 				 * as that keeps the maximum number of fingers.
 				 */
 				if (two_finger_scroll) {
-					if (w == 0) {
+					if (nfingers == 2) {
 						synaction->in_vscroll +=
 						    dyp ? 2 : 0;
 						synaction->in_vscroll +=
@@ -3030,7 +3214,7 @@
 					        vscroll_hor_area) ||
 					    (vscroll_hor_area < 0 &&
 					     synaction->start_y >=
-					     6143 + vscroll_hor_area))
+					     max_y + vscroll_hor_area))
 						synaction->in_vscroll += 2;
 
 					/* Check for vertical scrolling. */
@@ -3039,7 +3223,7 @@
 						vscroll_ver_area) ||
 					    (vscroll_ver_area < 0 &&
 					     synaction->start_x >=
-					     6143 + vscroll_ver_area))
+					     max_x + vscroll_ver_area))
 						synaction->in_vscroll += 1;
 				}
 
@@ -3053,8 +3237,10 @@
 		 * Reset two finger scrolling when the number of fingers
 		 * is different from two.
 		 */
-		if (two_finger_scroll && w != 0)
+		if (two_finger_scroll && nfingers != 2 && synaction->in_vscroll != 0) {
 			synaction->in_vscroll = 0;
+			exiting_scroll = 1;
+		}
 
 		VLOG(5, (LOG_DEBUG,
 			"synaptics: virtual scrolling: %s "
@@ -3077,12 +3263,12 @@
 			 * using this area, we apply a special weight and
 			 * div.
 			 */
-			if (x0 <= na_left || x0 >= 6143 - na_right) {
+			if (x0 <= na_left || x0 >= max_x - na_right) {
 				weight_prev_x = sc->syninfo.weight_previous_na;
 				div_max_x = sc->syninfo.div_max_na;
 			}
 
-			if (y0 <= na_bottom || y0 >= 6143 - na_top) {
+			if (y0 <= na_bottom || y0 >= max_y - na_top) {
 				weight_prev_y = sc->syninfo.weight_previous_na;
 				div_max_y = sc->syninfo.div_max_na;
 			}
@@ -3162,6 +3348,10 @@
 			/* The pointer is not moved. */
 			*x = *y = 0;
 		} else {
+			/* On exit the x/y pos may jump, ignore this */
+			if (exiting_scroll)
+				*x = *y = 0;
+
 			VLOG(3, (LOG_DEBUG, "synaptics: [%d, %d] -> [%d, %d]\n",
 			    dx, dy, *x, *y));
 		}
@@ -3170,10 +3360,8 @@
 		 * An action is currently taking place but the pressure
 		 * dropped under the minimum, putting an end to it.
 		 */
-		synapticsaction_t *synaction;
 		int taphold_timeout, dx, dy, tap_max_delta;
 
-		synaction = &(sc->synaction);
 		dx = abs(synaction->queue[synaction->queue_cursor].x -
 		    synaction->start_x);
 		dy = abs(synaction->queue[synaction->queue_cursor].y -
@@ -3224,6 +3412,12 @@
 				    "synaptics: button RELEASE: %d\n",
 				    synaction->tap_button));
 				sc->flags |= PSM_FLAGS_FINGERDOWN;
+
+				/* Schedule button press on next interrupt */
+				sc->idletimeout.tv_sec  = psmhz > 1 ?
+				    0 : 1;
+				sc->idletimeout.tv_usec = psmhz > 1 ?
+				    1000000 / psmhz : 0;
 			} else {
 				/*
 				 * This is the first tap: we set the
@@ -3236,6 +3430,7 @@
 				    1000000;
 				sc->taptimeout.tv_usec = taphold_timeout %
 				    1000000;
+				sc->idletimeout = sc->taptimeout;
 				timevaladd(&sc->taptimeout, &sc->lastsoftintr);
 
 				switch (synaction->fingers_nb) {
@@ -3272,7 +3467,7 @@
 			}
 		}
 	} else if (!(sc->flags & PSM_FLAGS_FINGERDOWN) &&
-	    sc->synaction.in_taphold) {
+	    synaction->in_taphold) {
 		/*
 		 * For a tap-hold to work, the button must remain down at
 		 * least until timeout (where the in_taphold flags will be
@@ -3279,45 +3474,467 @@
 		 * cleared) or during the next action.
 		 */
 		if (timevalcmp(&sc->lastsoftintr, &sc->taptimeout, <=)) {
-			ms->button |= sc->synaction.tap_button;
+			ms->button |= synaction->tap_button;
 		} else {
 			VLOG(2, (LOG_DEBUG,
 			    "synaptics: button RELEASE: %d\n",
-			    sc->synaction.tap_button));
-			sc->synaction.in_taphold = 0;
+			    synaction->tap_button));
+			synaction->in_taphold = 0;
 		}
 	}
 
-SYNAPTICS_END:
+	return;
+}
+
+static int
+psmsoftbuttons(struct psm_softc *sc, finger_t f, int pressed)
+{
+	static int button = 0;
+	int y_ok, center_button, center_x, right_button, right_x;
+
+	/* Dont change clickpad softbutton after pressing */
+	if (pressed && !button) {
+		y_ok = sc->syninfo.softbuttons_y >= 0 ?
+		    f.y < sc->syninfo.softbuttons_y :
+		    f.y > sc->synhw.maximumYCoord - sc->syninfo.softbuttons_y;
+
+		center_button = MOUSE_BUTTON2DOWN;
+		center_x = sc->syninfo.softbutton2_x;
+		right_button = MOUSE_BUTTON3DOWN;
+		right_x = sc->syninfo.softbutton3_x;
+
+		if (center_x > 0 && right_x > 0 && center_x > right_x) {
+			center_button = MOUSE_BUTTON3DOWN;
+			center_x = sc->syninfo.softbutton3_x;
+			right_button = MOUSE_BUTTON2DOWN;
+			right_x = sc->syninfo.softbutton2_x;
+		}
+
+		if (right_x > 0 && f.x > right_x && y_ok)
+			button = right_button;
+		else if (center_x > 0 && f.x > center_x && y_ok)
+			button = center_button;
+		else
+			button = MOUSE_BUTTON1DOWN;
+		VLOG(2, (LOG_DEBUG, "softbutton: PRESS: %d\n", button));
+	}
+
+	/* Clickpad releases */
+	if (!pressed && button) {
+		VLOG(2, (LOG_DEBUG, "softbutton: RELEASE: %d\n", button));
+		button = 0;
+	}
+
+	return (button);
+}
+
+static int
+proc_elantech(struct psm_softc *sc, packetbuf_t *pb, mousestatus_t *ms,
+    int *x, int *y, int *z)
+{
+	static int touchpad_button, trackpoint_button;
+	static int v4nfingers = 0;
+	finger_t fn, f[PSM_GESTURE_FINGERS];
+	int pkt, id, scale, i, nfingers, reset_queue;
+
+	if (!elantech_support)
+		return (0);
+
+	/* Determine packet format and do a sanity check for out of sync packets. */
+	if (ELANTECH_PKT_IS_DEBOUNCE(pb, sc->elanhw.hwversion))
+		pkt = ELANTECH_PKT_NOP;
+	else if (ELANTECH_PKT_IS_TRACKPOINT(pb))
+		pkt = ELANTECH_PKT_TRACKPOINT;
+	else
+	switch (sc->elanhw.hwversion) {
+	case 2:
+		if (!ELANTECH_PKT_IS_V2(pb))
+			return (-1);
+
+		pkt = (pb->ipacket[0] & 0xc0) == 0x80 ?
+		    ELANTECH_PKT_V2_2FINGER : ELANTECH_PKT_V2_COMMON;
+		break;
+	case 3:
+		if (!ELANTECH_PKT_IS_V3_HEAD(pb, sc->elanhw.hascrc) &&
+		    !ELANTECH_PKT_IS_V3_TAIL(pb, sc->elanhw.hascrc))
+			return (-1);
+
+		pkt = ELANTECH_PKT_V3;
+		break;
+	case 4:
+		if (!ELANTECH_PKT_IS_V4(pb, sc->elanhw.hascrc))
+			return (-1);
+
+		switch (pb->ipacket[3] & 0x03) {
+		case 0x00:
+			pkt = ELANTECH_PKT_V4_STATUS;
+			break;
+		case 0x01:
+			pkt = ELANTECH_PKT_V4_HEAD;
+			break;
+		case 0x02:
+			pkt = ELANTECH_PKT_V4_MOTION;
+			break;
+		default:
+			return (-1);
+		}
+		break;
+	default:
+		return (-1);
+	}
+
+	VLOG(5, (LOG_DEBUG, "elantech: ipacket format: %d\n", pkt));
+
+	for (id = 0; id < PSM_GESTURE_FINGERS; id++)
+		PSM_FINGER_RESET(f[id]);
+
+	*x = *y = *z = 0;
+	ms->button = ms->obutton;
+
+	if (sc->syninfo.touchpad_off)
+		return (0);
+
+	/* Common legend
+	 * L: Left mouse button pressed
+	 * R: Right mouse button pressed
+	 * N: number of fingers on touchpad
+	 * X: absolute x value (horizontal)
+	 * Y: absolute y value (vertical)
+	 * W; width of the finger touch
+	 * P: pressure
+	 */
+	switch (pkt) {
+	case ELANTECH_PKT_V2_COMMON:	/* HW V2. One/Three finger touch */
+		/*               7   6   5   4   3   2   1   0 (LSB)
+		 * -------------------------------------------
+		 * ipacket[0]:  N1  N0  W3  W2   .   .   R   L
+		 * ipacket[1]:  P7  P6  P5  P4 X11 X10  X9  X8
+		 * ipacket[2]:  X7  X6  X5  X4  X3  X2  X1  X0
+		 * ipacket[3]:  N4  VF  W1  W0   .   .   .  B2
+		 * ipacket[4]:  P3  P1  P2  P0 Y11 Y10  Y9  Y8
+		 * ipacket[5]:  Y7  Y6  Y5  Y4  Y3  Y2  Y1  Y0
+		 * -------------------------------------------
+		 * N4: set if more than 3 fingers (only in 3 fingers mode)
+		 * VF: a kind of flag? (only on EF123, 0 when finger
+		 *     is over one of the buttons, 1 otherwise)
+		 * B2: (on EF113 only, 0 otherwise), one button pressed
+		 * P & W is not reported on EF113 touchpads
+		 */
+		nfingers = (pb->ipacket[0] & 0xc0) >> 6;
+
+		fn = ELANTECH_FINGER_SET_XYP(pb);
+		if (sc->elanhw.haspressure) {
+			fn.w = ((pb->ipacket[0] & 0x30) >> 2) |
+			    ((pb->ipacket[3] & 0x30) >> 4);
+		} else {
+			fn.p = ELANTECH_FINGER_DEFAULT_P;
+			fn.w = ELANTECH_FINGER_DEFAULT_W;
+		}
+
+		/*
+		 * HW v2 dont report exact finger positions when 3 or more
+		 * fingers are on touchpad. Use reported value as fingers
+		 * position as it is required for tap detection
+		 */
+		if (nfingers > 2) {
+			fn.flags = PSM_FINGER_FUZZY;
+			f[0] = f[1] = fn;
+		}
+
+		id = nfingers - 1;
+		if (id >= 0 && id < PSM_GESTURE_FINGERS)
+			f[id] = fn;
+		break;
+
+	case ELANTECH_PKT_V2_2FINGER:	/*HW V2. Two finger touch */
+		/*               7   6   5   4   3   2   1   0 (LSB)
+		 * -------------------------------------------
+		 * ipacket[0]:  N1  N0 AY8 AX8   .   .   R   L
+		 * ipacket[1]: AX7 AX6 AX5 AX4 AX3 AX2 AX1 AX0
+		 * ipacket[2]: AY7 AY6 AY5 AY4 AY3 AY2 AY1 AY0
+		 * ipacket[3]:   .   . BY8 BX8   .   .   .   .
+		 * ipacket[4]: BX7 BX6 BX5 BX4 BX3 BX2 BX1 BX0
+		 * ipacket[5]: BY7 BY6 BY5 BY4 BY3 BY2 BY1 BY0
+		 * -------------------------------------------
+		 * AX: lower-left finger absolute x value
+		 * AY: lower-left finger absolute y value
+		 * BX: upper-right finger absolute x value
+		 * BY: upper-right finger absolute y value
+		 */
+		nfingers = 2;
+
+		VLOG(5, (LOG_DEBUG, "elantech: v2 BBX: [%d, %d] [%d, %d]\n",
+		    ((pb->ipacket[0] & 0x10) << 4) | pb->ipacket[1],
+		    ((pb->ipacket[0] & 0x20) << 3) | pb->ipacket[2],
+		    ((pb->ipacket[3] & 0x10) << 4) | pb->ipacket[4],
+		    ((pb->ipacket[3] & 0x20) << 3) | pb->ipacket[5]
+		));
+		for (id = 0; id < imin(2, PSM_GESTURE_FINGERS); id ++)
+			f[id] = (finger_t) {
+				.x = (((pb->ipacket[id * 3] & 0x10) << 4) |
+				    pb->ipacket[id * 3 + 1]) << 2,
+				.y = (((pb->ipacket[id * 3] & 0x20) << 3) |
+				    pb->ipacket[id * 3 + 2]) << 2,
+				.p = ELANTECH_FINGER_DEFAULT_P,
+				.w = ELANTECH_FINGER_DEFAULT_W,
+				/* HW ver.2 sends bounding box */
+				.flags = PSM_FINGER_FUZZY
+			};
+		break;
+
+	case ELANTECH_PKT_V3:	/* HW Version 3 */
+		/*               7   6   5   4   3   2   1   0 (LSB)
+		 * -------------------------------------------
+		 * ipacket[0]:  N1  N0  W3  W2   0   1   R   L
+		 * ipacket[1]:  P7  P6  P5  P4 X11 X10  X9  X8
+		 * ipacket[2]:  X7  X6  X5  X4  X3  X2  X1  X0
+		 * ipacket[3]:   0   0  W1  W0   0   0   1   0
+		 * ipacket[4]:  P3  P1  P2  P0 Y11 Y10  Y9  Y8
+		 * ipacket[5]:  Y7  Y6  Y5  Y4  Y3  Y2  Y1  Y0
+		 * -------------------------------------------
+		 */
+		nfingers = (pb->ipacket[0] & 0xc0) >> 6;
+		id = nfingers - 1;
+
+		fn = ELANTECH_FINGER_SET_XYP(pb);
+		fn.w = ((pb->ipacket[0] & 0x30) >> 2) |
+		    ((pb->ipacket[3] & 0x30) >> 4);
+
+		/*
+		 * HW v3 dont report exact finger positions when 3 or more
+		 * fingers are on touchpad. Use reported value as fingers
+		 * position as it is required for tap detection
+		 */
+		if (nfingers > 2) {
+			fn.flags = PSM_FINGER_FUZZY;
+			f[0] = f[1] = fn;
+		}
+
+		if (nfingers == 2 &&
+		    ELANTECH_PKT_IS_V3_HEAD(pb, sc->elanhw.hascrc))
+			id = 0;
+
+		if (id >= 0 && id < PSM_GESTURE_FINGERS) {
+			f[id] = fn;
+		}
+		break;
+
+	case ELANTECH_PKT_V4_STATUS:	/* HW Version 4. Status packet */
+		/*               7   6   5   4   3   2   1   0 (LSB)
+		 * -------------------------------------------
+		 * ipacket[0]:   .   .   .   .   0   1   R   L
+		 * ipacket[1]:   .   .   .  F4  F3  F2  F1  F0
+		 * ipacket[2]:   .   .   .   .   .   .   .   .
+		 * ipacket[3]:   .   .   .   1   0   0   0   0
+		 * ipacket[4]:  PL   .   .   .   .   .   .   .
+		 * ipacket[5]:   .   .   .   .   .   .   .   .
+		 * -------------------------------------------
+		 * Fn: finger n is on touchpad
+		 * PL: palm
+		 * HV ver4 sends a status packet to indicate that the numbers
+		 * or identities of the fingers has been changed
+		 */
+
+		v4nfingers = fls(pb->ipacket[1] & 0x1f);
+
+		if (v4nfingers > sc->elanaction.nfingers)
+			return (0);
+
+		nfingers = v4nfingers;
+
+		break;
+
+	case ELANTECH_PKT_V4_HEAD:	/* HW Version 4. Head packet */
+		/*               7   6   5   4   3   2   1   0 (LSB)
+		 * -------------------------------------------
+		 * ipacket[0]:  W3  W2  W1  W0   0   1   R   L
+		 * ipacket[1]:  P7  P6  P5  P4 X11 X10  X9  X8
+		 * ipacket[2]:  X7  X6  X5  X4  X3  X2  X1  X0
+		 * ipacket[3]: ID2 ID1 ID0   1   0   0   0   1
+		 * ipacket[4]:  P3  P1  P2  P0 Y11 Y10  Y9  Y8
+		 * ipacket[5]:  Y7  Y6  Y5  Y4  Y3  Y2  Y1  Y0
+		 * -------------------------------------------
+		 * ID: finger id
+		 * HW ver 4 sends head packets in two cases:
+		 * 1. One finger touch and movement.
+		 * 2. Next after status packet to tell new finger positions.
+		 */
+		nfingers = v4nfingers;
+		id = ((pb->ipacket[3] & 0xe0) >> 5) - 1;
+
+		if (id >= 0 && id < PSM_GESTURE_FINGERS) {
+			f[id] = ELANTECH_FINGER_SET_XYP(pb);
+			f[id].w = (pb->ipacket[0] & 0xf0) >> 4;
+		}
+		break;
+
+	case ELANTECH_PKT_V4_MOTION:	/* HW Version 4. Motion packet */
+		/*               7   6   5   4   3   2   1   0 (LSB)
+		 * -------------------------------------------
+		 * ipacket[0]: ID2 ID1 ID0  OF   0   1   R   L
+		 * ipacket[1]: DX7 DX6 DX5 DX4 DX3 DX2 DX1 DX0
+		 * ipacket[2]: DY7 DY6 DY5 DY4 DY3 DY2 DY1 DY0
+		 * ipacket[3]: ID2 ID1 ID0   1   0   0   1   0
+		 * ipacket[4]: DX7 DX6 DX5 DX4 DX3 DX2 DX1 DX0
+		 * ipacket[5]: DY7 DY6 DY5 DY4 DY3 DY2 DY1 DY0
+		 * -------------------------------------------
+		 * OF: delta overflows (> 127 or < -128), in this case
+		 *     firmware sends us (delta x / 5) and (delta y / 5)
+		 * ID: finger id
+		 * DX: delta x (two's complement)
+		 * XY: delta y (two's complement)
+		 * byte 0 ~ 2 for one finger
+		 * byte 3 ~ 5 for another finger
+		 */
+		nfingers = v4nfingers;
+
+		scale = (pb->ipacket[0] & 0x10) ? 5 : 1;
+		for (i = 0; i <= 3; i += 3) {
+			id = ((pb->ipacket[i] & 0xe0) >> 5) - 1;
+			if (id < 0 || id >= PSM_GESTURE_FINGERS)
+				continue;
+
+			if (PSM_FINGER_IS_SET(sc->elanaction.fingers[id])) {
+				f[id] = sc->elanaction.fingers[id];
+				f[id].x += imax(-f[id].x,
+				    (signed char)pb->ipacket[i+1] * scale);
+				f[id].y += imax(-f[id].y,
+				    (signed char)pb->ipacket[i+2] * scale);
+			} else {
+				VLOG(3, (LOG_DEBUG, "elantech: "
+				    "HW v4 motion packet skipped\n"));
+			}
+		}
+
+		break;
+
+	case ELANTECH_PKT_TRACKPOINT:
+		/*               7   6   5   4   3   2   1   0 (LSB)
+		 * -------------------------------------------
+		 * ipacket[0]:   0   0  SX  SY   0   M   R   L
+		 * ipacket[1]: ~SX   0   0   0   0   0   0   0
+		 * ipacket[2]: ~SY   0   0   0   0   0   0   0
+		 * ipacket[3]:   0   0 ~SY ~SX   0   1   1   0
+		 * ipacket[4]:  X7  X6  X5  X4  X3  X2  X1  X0
+		 * ipacket[5]:  Y7  Y6  Y5  Y4  Y3  Y2  Y1  Y0
+		 * -------------------------------------------
+		 * X and Y are written in two's complement spread
+		 * over 9 bits with SX/SY the relative top bit and
+		 * X7..X0 and Y7..Y0 the lower bits.
+		 */
+		*x = (pb->ipacket[0] & 0x20) ?
+		    pb->ipacket[4] - 256 : pb->ipacket[4];
+		*y = (pb->ipacket[0] & 0x10) ?
+		    pb->ipacket[5] - 256 : pb->ipacket[5];
+
+		trackpoint_button =
+		    ((pb->ipacket[0] & 0x01) ? MOUSE_BUTTON1DOWN : 0) |
+		    ((pb->ipacket[0] & 0x02) ? MOUSE_BUTTON3DOWN : 0) |
+		    ((pb->ipacket[0] & 0x04) ? MOUSE_BUTTON2DOWN : 0);
+
+		ms->button = touchpad_button | trackpoint_button;
+		return (0);
+
+	case ELANTECH_PKT_NOP:
+		return (0);
+
+	default:
+		return (-1);
+	}
+
+	for (id = 0; id < PSM_GESTURE_FINGERS; id++)
+		if (PSM_FINGER_IS_SET(f[id]))
+			VLOG(2, (LOG_DEBUG, "elantech: "
+			    "finger %d: down [%d, %d], %d, %d, %d\n", id + 1,
+			    f[id].x, f[id].y, f[id].p, f[id].w, f[id].flags));
+
+	/* Touchpad button presses */
+	if (sc->elanhw.isclickpad) {
+		touchpad_button =
+		    psmsoftbuttons(sc, f[0], pb->ipacket[0] & 0x03);
+	} else {
+		touchpad_button =
+		    ((pb->ipacket[0] & 0x01) ? MOUSE_BUTTON1DOWN : 0) |
+		    ((pb->ipacket[0] & 0x02) ? MOUSE_BUTTON3DOWN : 0);
+	}
+
+	ms->button = touchpad_button | trackpoint_button;
+
 	/*
-	 * Use the extra buttons as a scrollwheel
-	 *
-	 * XXX X.Org uses the Z axis for vertical wheel only,
-	 * whereas moused(8) understands special values to differ
-	 * vertical and horizontal wheels.
-	 *
-	 * xf86-input-mouse needs therefore a small patch to
-	 * understand these special values. Without it, the
-	 * horizontal wheel acts as a vertical wheel in X.Org.
-	 *
-	 * That's why the horizontal wheel is disabled by
-	 * default for now.
+	 * Send finger positions to movement smoother.
+	 * Try to avoid nonreenterable code paths of movement smoother
+	 * like initialization and tap processing for 2nd finger.
 	 */
+	for (id = 0; id < PSM_GESTURE_FINGERS; id++) {
 
-	if (ms->button & MOUSE_BUTTON4DOWN) {
+		if (!(PSM_FINGER_IS_SET(f[id]) || (id == 0 && nfingers == 0)))
+			continue;
+		if (id == 1 && sc->syninfo.two_finger_scroll == 0)
+			continue;
+
+		reset_queue = 0;
+
+		/* Avoid cursor jumping on switching real<->fuzzy position */
+		if (PSM_FINGER_IS_SET(f[id]) &&
+		    ((f[id].flags & PSM_FINGER_FUZZY) !=
+		     (sc->elanaction.fingers[id].flags & PSM_FINGER_FUZZY)))
+			reset_queue = 1;
+
+		/* Reset 2-nd finger synaction queue on action start */
+		if (id > 0 && !PSM_FINGER_IS_SET(sc->elanaction.fingers[id])) {
+			reset_queue = 1;
+		}
+
+		if (reset_queue) {
+			VLOG(3, (LOG_DEBUG, "elantech: "
+			    "finger %d: reset synaptics queue\n", id + 1));
+			sc->synaction[id].queue_cursor = 0;
+			sc->synaction[id].queue_len = 0;
+			sc->synaction[id].queue[0].x = f[id].x;
+			sc->synaction[id].queue[0].y = f[id].y;
+			sc->synaction[id].start_x = f[id].x;
+			sc->synaction[id].start_y = f[id].y;
+			sc->synaction[id].window_min = sc->syninfo.window_min;
+			sc->synaction[id].squelch_x = 0;
+			sc->synaction[id].squelch_y = 0;
+			sc->synaction[id].avg_dx = 0;
+			sc->synaction[id].avg_dy = 0;
+			sc->synaction[id].fingers_nb = 0;
+			sc->synaction[id].in_vscroll = 0;
+		}
+
+		/* prevent palm detection for fuzzy finger touches */
+		if (f[id].flags & PSM_FINGER_FUZZY) {
+			f[id].p = ELANTECH_FINGER_DEFAULT_P;
+			f[id].w = ELANTECH_FINGER_DEFAULT_W;
+		}
+
+		psmgestures(sc, &sc->synaction[id], f[id], imin(nfingers, 3),
+		    ms, x, y);
+	}
+
+	/* Store current finger positions in action context */
+	sc->elanaction.nfingers = nfingers;
+	for (id = 0; id < PSM_GESTURE_FINGERS; id++) {
+		if (PSM_FINGER_IS_SET(f[id]))
+			sc->elanaction.fingers[id] = f[id];
+		if (id >= nfingers)
+			PSM_FINGER_RESET(sc->elanaction.fingers[id]);
+	}
+
+	/* Use the extra buttons as a scrollwheel */
+	if (ms->button & MOUSE_BUTTON4DOWN)
 		*z = -1;
-		ms->button &= ~MOUSE_BUTTON4DOWN;
-	} else if (ms->button & MOUSE_BUTTON5DOWN) {
+	else if (ms->button & MOUSE_BUTTON5DOWN)
 		*z = 1;
-		ms->button &= ~MOUSE_BUTTON5DOWN;
-	} else if (ms->button & MOUSE_BUTTON6DOWN) {
+	else if (ms->button & MOUSE_BUTTON6DOWN)
 		*z = -2;
-		ms->button &= ~MOUSE_BUTTON6DOWN;
-	} else if (ms->button & MOUSE_BUTTON7DOWN) {
+	else if (ms->button & MOUSE_BUTTON7DOWN)
 		*z = 2;
-		ms->button &= ~MOUSE_BUTTON7DOWN;
-	} else
+	else
 		*z = 0;
+	ms->button &= ~(MOUSE_BUTTON4DOWN | MOUSE_BUTTON5DOWN |
+	    MOUSE_BUTTON6DOWN | MOUSE_BUTTON7DOWN);
 
 	return (0);
 }
@@ -3390,6 +4007,31 @@
 }
 
 static void
+psmsoftintridle(void *arg)
+{
+	struct psm_softc *sc = arg;
+	packetbuf_t *pb;
+
+	/* Invoke soft handler only when pqueue is empty. Otherwise it will be
+	 * invoked from psmintr soon with pqueue filled with real data */
+	if (sc->pqueue_start == sc->pqueue_end &&
+	    sc->idlepacket.inputbytes > 0) {
+		/* Grow circular queue backwards to avoid race with psmintr */
+		if (--sc->pqueue_start < 0)
+			sc->pqueue_start = PSM_PACKETQUEUE - 1;
+
+		pb = &sc->pqueue[sc->pqueue_start];
+		memcpy(pb, &sc->idlepacket, sizeof(packetbuf_t));
+		VLOG(4, (LOG_DEBUG,
+		    "psmsoftintridle: %02x %02x %02x %02x %02x %02x\n",
+		    pb->ipacket[0], pb->ipacket[1], pb->ipacket[2],
+		    pb->ipacket[3], pb->ipacket[4], pb->ipacket[5]));
+
+		psmsoftintr(arg);
+	}
+}
+
+static void
 psmsoftintr(void *arg)
 {
 	/*
@@ -3442,6 +4084,8 @@
 		if (sc->config & PSM_CONFIG_FORCETAP)
 			ms.button |= ((c & MOUSE_PS2_TAP)) ?
 			    0 : MOUSE_BUTTON4DOWN;
+		timevalclear(&sc->idletimeout);
+		sc->idlepacket.inputbytes = 0;
 
 		switch (sc->hw.model) {
 
@@ -3580,6 +4224,11 @@
 				goto next;
 			break;
 
+		case MOUSE_MODEL_ELANTECH:
+			if (proc_elantech(sc, pb, &ms, &x, &y, &z) != 0)
+				goto next;
+			break;
+
 		case MOUSE_MODEL_TRACKPOINT:
 		case MOUSE_MODEL_GENERIC:
 		default:
@@ -3604,6 +4253,10 @@
 		}
 	}
 
+	/* Store last packet for reinjection if it has not been set already */
+	if (timevalisset(&sc->idletimeout) && sc->idlepacket.inputbytes == 0)
+		sc->idlepacket = *pb;
+
 	ms.dx = x;
 	ms.dy = y;
 	ms.dz = z;
@@ -3650,6 +4303,16 @@
 		pgsigio(&sc->async, SIGIO, 0);
 	}
 	sc->state &= ~PSM_SOFTARMED;
+
+	/* schedule injection of predefined packet after idletimeout
+	 * if no data packets have been received from psmintr */
+	if (timevalisset(&sc->idletimeout)) {
+		sc->state |= PSM_SOFTARMED;
+		callout_reset(&sc->softcallout, tvtohz(&sc->idletimeout),
+		    psmsoftintridle, sc);
+		VLOG(2, (LOG_DEBUG, "softintr: callout set: %d ticks\n",
+		    tvtohz(&sc->idletimeout)));
+	}
 	splx(s);
 }
 
@@ -3710,8 +4373,9 @@
 #ifdef notyet
 /* Logitech MouseMan Cordless II */
 static int
-enable_lcordless(KDBC kbdc, struct psm_softc *sc)
+enable_lcordless(struct psm_softc *sc, enum probearg arg)
 {
+	KBDC kbdc = sc->kbdc;
 	int status[3];
 	int ch;
 
@@ -3732,8 +4396,9 @@
 
 /* Genius NetScroll Mouse, MouseSystems SmartScroll Mouse */
 static int
-enable_groller(KBDC kbdc, struct psm_softc *sc)
+enable_groller(struct psm_softc *sc, enum probearg arg)
 {
+	KBDC kbdc = sc->kbdc;
 	int status[3];
 
 	/*
@@ -3762,7 +4427,7 @@
 	if ((status[1] != '3') || (status[2] != 'D'))
 		return (FALSE);
 	/* FIXME: SmartScroll Mouse has 5 buttons! XXX */
-	if (sc != NULL)
+	if (arg == PROBE)
 		sc->hw.buttons = 4;
 	return (TRUE);
 }
@@ -3769,8 +4434,9 @@
 
 /* Genius NetMouse/NetMouse Pro, ASCII Mie Mouse, NetScroll Optical */
 static int
-enable_gmouse(KBDC kbdc, struct psm_softc *sc)
+enable_gmouse(struct psm_softc *sc, enum probearg arg)
 {
+	KBDC kbdc = sc->kbdc;
 	int status[3];
 
 	/*
@@ -3792,8 +4458,9 @@
 
 /* ALPS GlidePoint */
 static int
-enable_aglide(KBDC kbdc, struct psm_softc *sc)
+enable_aglide(struct psm_softc *sc, enum probearg arg)
 {
+	KBDC kbdc = sc->kbdc;
 	int status[3];
 
 	/*
@@ -3814,9 +4481,10 @@
 
 /* Kensington ThinkingMouse/Trackball */
 static int
-enable_kmouse(KBDC kbdc, struct psm_softc *sc)
+enable_kmouse(struct psm_softc *sc, enum probearg arg)
 {
 	static u_char rate[] = { 20, 60, 40, 20, 20, 60, 40, 20, 20 };
+	KBDC kbdc = sc->kbdc;
 	int status[3];
 	int id1;
 	int id2;
@@ -3867,8 +4535,9 @@
 
 /* Logitech MouseMan+/FirstMouse+, IBM ScrollPoint Mouse */
 static int
-enable_mmanplus(KBDC kbdc, struct psm_softc *sc)
+enable_mmanplus(struct psm_softc *sc, enum probearg arg)
 {
+	KBDC kbdc = sc->kbdc;
 	int data[3];
 
 	/* the special sequence to enable the fourth button and the roller. */
@@ -3909,7 +4578,7 @@
 	if (MOUSE_PS2PLUS_PACKET_TYPE(data) != 0)
 		return (FALSE);
 
-	if (sc != NULL) {
+	if (arg == PROBE) {
 		sc->hw.hwid &= 0x00ff;
 		sc->hw.hwid |= data[2] << 8;	/* save model ID */
 	}
@@ -3925,8 +4594,9 @@
 
 /* MS IntelliMouse Explorer */
 static int
-enable_msexplorer(KBDC kbdc, struct psm_softc *sc)
+enable_msexplorer(struct psm_softc *sc, enum probearg arg)
 {
+	KBDC kbdc = sc->kbdc;
 	static u_char rate0[] = { 200, 100, 80, };
 	static u_char rate1[] = { 200, 200, 80, };
 	int id;
@@ -3937,7 +4607,7 @@
 	 * straight to Explorer mode, but need to be set to Intelli mode
 	 * first.
 	 */
-	enable_msintelli(kbdc, sc);
+	enable_msintelli(sc, arg);
 
 	/* the special sequence to enable the extra buttons and the roller. */
 	for (i = 0; i < sizeof(rate1)/sizeof(rate1[0]); ++i)
@@ -3948,7 +4618,7 @@
 	if (id != PSM_EXPLORER_ID)
 		return (FALSE);
 
-	if (sc != NULL) {
+	if (arg == PROBE) {
 		sc->hw.buttons = 5;	/* IntelliMouse Explorer XXX */
 		sc->hw.hwid = id;
 	}
@@ -3971,15 +4641,15 @@
 	return (TRUE);
 }
 
-/* MS IntelliMouse */
+/*
+ * MS IntelliMouse
+ * Logitech MouseMan+ and FirstMouse+ will also respond to this
+ * probe routine and act like IntelliMouse.
+ */
 static int
-enable_msintelli(KBDC kbdc, struct psm_softc *sc)
+enable_msintelli(struct psm_softc *sc, enum probearg arg)
 {
-	/*
-	 * Logitech MouseMan+ and FirstMouse+ will also respond to this
-	 * probe routine and act like IntelliMouse.
-	 */
-
+	KBDC kbdc = sc->kbdc;
 	static u_char rate[] = { 200, 100, 80, };
 	int id;
 	int i;
@@ -3993,7 +4663,7 @@
 	if (id != PSM_INTELLI_ID)
 		return (FALSE);
 
-	if (sc != NULL) {
+	if (arg == PROBE) {
 		sc->hw.buttons = 3;
 		sc->hw.hwid = id;
 	}
@@ -4001,15 +4671,15 @@
 	return (TRUE);
 }
 
-/* A4 Tech 4D Mouse */
+/*
+ * A4 Tech 4D Mouse
+ * Newer wheel mice from A4 Tech may use the 4D+ protocol.
+ */
 static int
-enable_4dmouse(KBDC kbdc, struct psm_softc *sc)
+enable_4dmouse(struct psm_softc *sc, enum probearg arg)
 {
-	/*
-	 * Newer wheel mice from A4 Tech may use the 4D+ protocol.
-	 */
-
 	static u_char rate[] = { 200, 100, 80, 60, 40, 20 };
+	KBDC kbdc = sc->kbdc;
 	int id;
 	int i;
 
@@ -4025,7 +4695,7 @@
 	if (id != PSM_4DMOUSE_ID)
 		return (FALSE);
 
-	if (sc != NULL) {
+	if (arg == PROBE) {
 		sc->hw.buttons = 3;	/* XXX some 4D mice have 4? */
 		sc->hw.hwid = id;
 	}
@@ -4033,14 +4703,15 @@
 	return (TRUE);
 }
 
-/* A4 Tech 4D+ Mouse */
+/*
+ * A4 Tech 4D+ Mouse
+ * Newer wheel mice from A4 Tech seem to use this protocol.
+ * Older models are recognized as either 4D Mouse or IntelliMouse.
+ */
 static int
-enable_4dplus(KBDC kbdc, struct psm_softc *sc)
+enable_4dplus(struct psm_softc *sc, enum probearg arg)
 {
-	/*
-	 * Newer wheel mice from A4 Tech seem to use this protocol.
-	 * Older models are recognized as either 4D Mouse or IntelliMouse.
-	 */
+	KBDC kbdc = sc->kbdc;
 	int id;
 
 	/*
@@ -4063,7 +4734,7 @@
 		return (FALSE);
 	}
 
-	if (sc != NULL) {
+	if (arg == PROBE) {
 		sc->hw.buttons = (id == PSM_4DPLUS_ID) ? 4 : 3;
 		sc->hw.hwid = id;
 	}
@@ -4075,10 +4746,17 @@
 static int
 synaptics_sysctl(SYSCTL_HANDLER_ARGS)
 {
+	struct psm_softc *sc;
 	int error, arg;
 
+	if (oidp->oid_arg1 == NULL || oidp->oid_arg2 < 0 ||
+	    oidp->oid_arg2 > SYNAPTICS_SYSCTL_SOFTBUTTON_NOMOVE)
+		return (EINVAL);
+
+	sc = oidp->oid_arg1;
+
 	/* Read the current value. */
-	arg = *(int *)oidp->oid_arg1;
+	arg = *(int *)((char *)sc + oidp->oid_arg2);
 	error = sysctl_handle_int(oidp, &arg, 0, req);
 
 	/* Sanity check. */
@@ -4100,14 +4778,19 @@
 			return (EINVAL);
 		break;
 	case SYNAPTICS_SYSCTL_MARGIN_TOP:
+	case SYNAPTICS_SYSCTL_MARGIN_BOTTOM:
+	case SYNAPTICS_SYSCTL_NA_TOP:
+	case SYNAPTICS_SYSCTL_NA_BOTTOM:
+		if (arg < 0 || arg > sc->synhw.maximumYCoord)
+			return (EINVAL);
+		break;
 	case SYNAPTICS_SYSCTL_MARGIN_RIGHT:
-	case SYNAPTICS_SYSCTL_MARGIN_BOTTOM:
 	case SYNAPTICS_SYSCTL_MARGIN_LEFT:
-	case SYNAPTICS_SYSCTL_NA_TOP:
 	case SYNAPTICS_SYSCTL_NA_RIGHT:
-	case SYNAPTICS_SYSCTL_NA_BOTTOM:
 	case SYNAPTICS_SYSCTL_NA_LEFT:
-		if (arg < 0 || arg > 6143)
+	case SYNAPTICS_SYSCTL_SOFTBUTTON2_X:
+	case SYNAPTICS_SYSCTL_SOFTBUTTON3_X:
+		if (arg < 0 || arg > sc->synhw.maximumXCoord)
 			return (EINVAL);
 		break;
 	case SYNAPTICS_SYSCTL_WINDOW_MIN:
@@ -4137,26 +4820,65 @@
 			return (EINVAL);
 		break;
 	case SYNAPTICS_SYSCTL_VSCROLL_HOR_AREA:
+		if (arg < -sc->synhw.maximumXCoord ||
+		    arg > sc->synhw.maximumXCoord)
+			return (EINVAL);
+		break;
 	case SYNAPTICS_SYSCTL_VSCROLL_VER_AREA:
-		if (arg < -6143 || arg > 6143)
+	case SYNAPTICS_SYSCTL_SOFTBUTTONS_Y:
+		if (arg < -sc->synhw.maximumYCoord ||
+		    arg > sc->synhw.maximumYCoord)
 			return (EINVAL);
 		break;
         case SYNAPTICS_SYSCTL_TOUCHPAD_OFF:
+	case SYNAPTICS_SYSCTL_SOFTBUTTON_NOMOVE:
 		if (arg < 0 || arg > 1)
 			return (EINVAL);
 		break;
+	case SYNAPTICS_SYSCTL_SOFTBUTTONS:
+		/* Softbuttons is clickpad only feature */
+		if (!sc->synhw.capClickPad && arg != 0)
+			return (EINVAL);
+		/* Set predefined sizes for softbuttons */
+		switch (arg) {
+		case 3:
+			sc->syninfo.softbutton3_x =
+			    sc->synhw.maximumXCoord * 2 / 3;
+			sc->syninfo.softbutton2_x =
+			    sc->synhw.maximumXCoord / 3;
+			sc->syninfo.softbuttons_y =
+			    sc->synhw.maximumYCoord / 4;
+			break;
+		case 2:
+			sc->syninfo.softbutton3_x =
+			    sc->synhw.maximumXCoord / 2;
+			sc->syninfo.softbutton2_x = 0;
+			sc->syninfo.softbuttons_y =
+			    sc->synhw.maximumYCoord / 4;
+			break;
+		case 1:
+		case 0:
+			sc->syninfo.softbutton3_x = 0;
+			sc->syninfo.softbutton2_x = 0;
+			sc->syninfo.softbuttons_y = 0;
+			break;
+		default:
+			return (EINVAL);
+		}
+		break;
 	default:
 		return (EINVAL);
 	}
 
 	/* Update. */
-	*(int *)oidp->oid_arg1 = arg;
+	*(int *)((char *)sc + oidp->oid_arg2) = arg;
 
 	return (error);
 }
 
 static void
-synaptics_sysctl_create_tree(struct psm_softc *sc)
+synaptics_sysctl_create_tree(struct psm_softc *sc, const char *name,
+    const char *descr)
 {
 
 	if (sc->syninfo.sysctl_tree != NULL)
@@ -4165,8 +4887,8 @@
 	/* Attach extra synaptics sysctl nodes under hw.psm.synaptics */
 	sysctl_ctx_init(&sc->syninfo.sysctl_ctx);
 	sc->syninfo.sysctl_tree = SYSCTL_ADD_NODE(&sc->syninfo.sysctl_ctx,
-	    SYSCTL_STATIC_CHILDREN(_hw_psm), OID_AUTO, "synaptics", CTLFLAG_RD,
-	    0, "Synaptics TouchPad");
+	    SYSCTL_STATIC_CHILDREN(_hw_psm), OID_AUTO, name, CTLFLAG_RD,
+	    0, descr);
 
 	/* hw.psm.synaptics.directional_scrolls. */
 	sc->syninfo.directional_scrolls = 0;
@@ -4182,7 +4904,8 @@
 	 * physical area reserved for scrolling or when
 	 * there's no multi finger support.
 	 */
-	if (sc->synhw.verticalScroll || sc->synhw.capMultiFinger == 0)
+	if (sc->synhw.verticalScroll || (sc->synhw.capMultiFinger == 0 &&
+					 sc->synhw.capAdvancedGestures == 0))
 		sc->syninfo.two_finger_scroll = 0;
 	else
 		sc->syninfo.two_finger_scroll = 1;
@@ -4198,7 +4921,7 @@
 	SYSCTL_ADD_PROC(&sc->syninfo.sysctl_ctx,
 	    SYSCTL_CHILDREN(sc->syninfo.sysctl_tree), OID_AUTO,
 	    "min_pressure", CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
-	    &sc->syninfo.min_pressure, SYNAPTICS_SYSCTL_MIN_PRESSURE,
+	    sc, SYNAPTICS_SYSCTL_MIN_PRESSURE,
 	    synaptics_sysctl, "I",
 	    "Minimum pressure required to start an action");
 
@@ -4207,7 +4930,7 @@
 	SYSCTL_ADD_PROC(&sc->syninfo.sysctl_ctx,
 	    SYSCTL_CHILDREN(sc->syninfo.sysctl_tree), OID_AUTO,
 	    "max_pressure", CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
-	    &sc->syninfo.max_pressure, SYNAPTICS_SYSCTL_MAX_PRESSURE,
+	    sc, SYNAPTICS_SYSCTL_MAX_PRESSURE,
 	    synaptics_sysctl, "I",
 	    "Maximum pressure to detect palm");
 
@@ -4216,7 +4939,7 @@
 	SYSCTL_ADD_PROC(&sc->syninfo.sysctl_ctx,
 	    SYSCTL_CHILDREN(sc->syninfo.sysctl_tree), OID_AUTO,
 	    "max_width", CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
-	    &sc->syninfo.max_width, SYNAPTICS_SYSCTL_MAX_WIDTH,
+	    sc, SYNAPTICS_SYSCTL_MAX_WIDTH,
 	    synaptics_sysctl, "I",
 	    "Maximum finger width to detect palm");
 
@@ -4225,7 +4948,7 @@
 	SYSCTL_ADD_PROC(&sc->syninfo.sysctl_ctx,
 	    SYSCTL_CHILDREN(sc->syninfo.sysctl_tree), OID_AUTO,
 	    "margin_top", CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
-	    &sc->syninfo.margin_top, SYNAPTICS_SYSCTL_MARGIN_TOP,
+	    sc, SYNAPTICS_SYSCTL_MARGIN_TOP,
 	    synaptics_sysctl, "I",
 	    "Top margin");
 
@@ -4234,7 +4957,7 @@
 	SYSCTL_ADD_PROC(&sc->syninfo.sysctl_ctx,
 	    SYSCTL_CHILDREN(sc->syninfo.sysctl_tree), OID_AUTO,
 	    "margin_right", CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
-	    &sc->syninfo.margin_right, SYNAPTICS_SYSCTL_MARGIN_RIGHT,
+	    sc, SYNAPTICS_SYSCTL_MARGIN_RIGHT,
 	    synaptics_sysctl, "I",
 	    "Right margin");
 
@@ -4243,7 +4966,7 @@
 	SYSCTL_ADD_PROC(&sc->syninfo.sysctl_ctx,
 	    SYSCTL_CHILDREN(sc->syninfo.sysctl_tree), OID_AUTO,
 	    "margin_bottom", CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
-	    &sc->syninfo.margin_bottom, SYNAPTICS_SYSCTL_MARGIN_BOTTOM,
+	    sc, SYNAPTICS_SYSCTL_MARGIN_BOTTOM,
 	    synaptics_sysctl, "I",
 	    "Bottom margin");
 
@@ -4252,7 +4975,7 @@
 	SYSCTL_ADD_PROC(&sc->syninfo.sysctl_ctx,
 	    SYSCTL_CHILDREN(sc->syninfo.sysctl_tree), OID_AUTO,
 	    "margin_left", CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
-	    &sc->syninfo.margin_left, SYNAPTICS_SYSCTL_MARGIN_LEFT,
+	    sc, SYNAPTICS_SYSCTL_MARGIN_LEFT,
 	    synaptics_sysctl, "I",
 	    "Left margin");
 
@@ -4261,7 +4984,7 @@
 	SYSCTL_ADD_PROC(&sc->syninfo.sysctl_ctx,
 	    SYSCTL_CHILDREN(sc->syninfo.sysctl_tree), OID_AUTO,
 	    "na_top", CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
-	    &sc->syninfo.na_top, SYNAPTICS_SYSCTL_NA_TOP,
+	    sc, SYNAPTICS_SYSCTL_NA_TOP,
 	    synaptics_sysctl, "I",
 	    "Top noisy area, where weight_previous_na is used instead "
 	    "of weight_previous");
@@ -4271,7 +4994,7 @@
 	SYSCTL_ADD_PROC(&sc->syninfo.sysctl_ctx,
 	    SYSCTL_CHILDREN(sc->syninfo.sysctl_tree), OID_AUTO,
 	    "na_right", CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
-	    &sc->syninfo.na_right, SYNAPTICS_SYSCTL_NA_RIGHT,
+	    sc, SYNAPTICS_SYSCTL_NA_RIGHT,
 	    synaptics_sysctl, "I",
 	    "Right noisy area, where weight_previous_na is used instead "
 	    "of weight_previous");
@@ -4281,7 +5004,7 @@
 	SYSCTL_ADD_PROC(&sc->syninfo.sysctl_ctx,
 	    SYSCTL_CHILDREN(sc->syninfo.sysctl_tree), OID_AUTO,
 	    "na_bottom", CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
-	    &sc->syninfo.na_bottom, SYNAPTICS_SYSCTL_NA_BOTTOM,
+	    sc, SYNAPTICS_SYSCTL_NA_BOTTOM,
 	    synaptics_sysctl, "I",
 	    "Bottom noisy area, where weight_previous_na is used instead "
 	    "of weight_previous");
@@ -4291,7 +5014,7 @@
 	SYSCTL_ADD_PROC(&sc->syninfo.sysctl_ctx,
 	    SYSCTL_CHILDREN(sc->syninfo.sysctl_tree), OID_AUTO,
 	    "na_left", CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
-	    &sc->syninfo.na_left, SYNAPTICS_SYSCTL_NA_LEFT,
+	    sc, SYNAPTICS_SYSCTL_NA_LEFT,
 	    synaptics_sysctl, "I",
 	    "Left noisy area, where weight_previous_na is used instead "
 	    "of weight_previous");
@@ -4301,7 +5024,7 @@
 	SYSCTL_ADD_PROC(&sc->syninfo.sysctl_ctx,
 	    SYSCTL_CHILDREN(sc->syninfo.sysctl_tree), OID_AUTO,
 	    "window_min", CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
-	    &sc->syninfo.window_min, SYNAPTICS_SYSCTL_WINDOW_MIN,
+	    sc, SYNAPTICS_SYSCTL_WINDOW_MIN,
 	    synaptics_sysctl, "I",
 	    "Minimum window size to start an action");
 
@@ -4310,7 +5033,7 @@
 	SYSCTL_ADD_PROC(&sc->syninfo.sysctl_ctx,
 	    SYSCTL_CHILDREN(sc->syninfo.sysctl_tree), OID_AUTO,
 	    "window_max", CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
-	    &sc->syninfo.window_max, SYNAPTICS_SYSCTL_WINDOW_MAX,
+	    sc, SYNAPTICS_SYSCTL_WINDOW_MAX,
 	    synaptics_sysctl, "I",
 	    "Maximum window size");
 
@@ -4319,7 +5042,7 @@
 	SYSCTL_ADD_PROC(&sc->syninfo.sysctl_ctx,
 	    SYSCTL_CHILDREN(sc->syninfo.sysctl_tree), OID_AUTO,
 	    "multiplicator", CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
-	    &sc->syninfo.multiplicator, SYNAPTICS_SYSCTL_MULTIPLICATOR,
+	    sc, SYNAPTICS_SYSCTL_MULTIPLICATOR,
 	    synaptics_sysctl, "I",
 	    "Multiplicator to increase precision in averages and divisions");
 
@@ -4328,7 +5051,7 @@
 	SYSCTL_ADD_PROC(&sc->syninfo.sysctl_ctx,
 	    SYSCTL_CHILDREN(sc->syninfo.sysctl_tree), OID_AUTO,
 	    "weight_current", CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
-	    &sc->syninfo.weight_current, SYNAPTICS_SYSCTL_WEIGHT_CURRENT,
+	    sc, SYNAPTICS_SYSCTL_WEIGHT_CURRENT,
 	    synaptics_sysctl, "I",
 	    "Weight of the current movement in the new average");
 
@@ -4337,7 +5060,7 @@
 	SYSCTL_ADD_PROC(&sc->syninfo.sysctl_ctx,
 	    SYSCTL_CHILDREN(sc->syninfo.sysctl_tree), OID_AUTO,
 	    "weight_previous", CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
-	    &sc->syninfo.weight_previous, SYNAPTICS_SYSCTL_WEIGHT_PREVIOUS,
+	    sc, SYNAPTICS_SYSCTL_WEIGHT_PREVIOUS,
 	    synaptics_sysctl, "I",
 	    "Weight of the previous average");
 
@@ -4346,8 +5069,7 @@
 	SYSCTL_ADD_PROC(&sc->syninfo.sysctl_ctx,
 	    SYSCTL_CHILDREN(sc->syninfo.sysctl_tree), OID_AUTO,
 	    "weight_previous_na", CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
-	    &sc->syninfo.weight_previous_na,
-	    SYNAPTICS_SYSCTL_WEIGHT_PREVIOUS_NA,
+	    sc, SYNAPTICS_SYSCTL_WEIGHT_PREVIOUS_NA,
 	    synaptics_sysctl, "I",
 	    "Weight of the previous average (inside the noisy area)");
 
@@ -4356,8 +5078,7 @@
 	SYSCTL_ADD_PROC(&sc->syninfo.sysctl_ctx,
 	    SYSCTL_CHILDREN(sc->syninfo.sysctl_tree), OID_AUTO,
 	    "weight_len_squared", CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
-	    &sc->syninfo.weight_len_squared,
-	    SYNAPTICS_SYSCTL_WEIGHT_LEN_SQUARED,
+	    sc, SYNAPTICS_SYSCTL_WEIGHT_LEN_SQUARED,
 	    synaptics_sysctl, "I",
 	    "Length (squared) of segments where weight_previous "
 	    "starts to decrease");
@@ -4367,7 +5088,7 @@
 	SYSCTL_ADD_PROC(&sc->syninfo.sysctl_ctx,
 	    SYSCTL_CHILDREN(sc->syninfo.sysctl_tree), OID_AUTO,
 	    "div_min", CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
-	    &sc->syninfo.div_min, SYNAPTICS_SYSCTL_DIV_MIN,
+	    sc, SYNAPTICS_SYSCTL_DIV_MIN,
 	    synaptics_sysctl, "I",
 	    "Divisor for fast movements");
 
@@ -4376,7 +5097,7 @@
 	SYSCTL_ADD_PROC(&sc->syninfo.sysctl_ctx,
 	    SYSCTL_CHILDREN(sc->syninfo.sysctl_tree), OID_AUTO,
 	    "div_max", CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
-	    &sc->syninfo.div_max, SYNAPTICS_SYSCTL_DIV_MAX,
+	    sc, SYNAPTICS_SYSCTL_DIV_MAX,
 	    synaptics_sysctl, "I",
 	    "Divisor for slow movements");
 
@@ -4385,7 +5106,7 @@
 	SYSCTL_ADD_PROC(&sc->syninfo.sysctl_ctx,
 	    SYSCTL_CHILDREN(sc->syninfo.sysctl_tree), OID_AUTO,
 	    "div_max_na", CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
-	    &sc->syninfo.div_max_na, SYNAPTICS_SYSCTL_DIV_MAX_NA,
+	    sc, SYNAPTICS_SYSCTL_DIV_MAX_NA,
 	    synaptics_sysctl, "I",
 	    "Divisor with slow movements (inside the noisy area)");
 
@@ -4394,7 +5115,7 @@
 	SYSCTL_ADD_PROC(&sc->syninfo.sysctl_ctx,
 	    SYSCTL_CHILDREN(sc->syninfo.sysctl_tree), OID_AUTO,
 	    "div_len", CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
-	    &sc->syninfo.div_len, SYNAPTICS_SYSCTL_DIV_LEN,
+	    sc, SYNAPTICS_SYSCTL_DIV_LEN,
 	    synaptics_sysctl, "I",
 	    "Length of segments where div_max starts to decrease");
 
@@ -4403,7 +5124,7 @@
 	SYSCTL_ADD_PROC(&sc->syninfo.sysctl_ctx,
 	    SYSCTL_CHILDREN(sc->syninfo.sysctl_tree), OID_AUTO,
 	    "tap_max_delta", CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
-	    &sc->syninfo.tap_max_delta, SYNAPTICS_SYSCTL_TAP_MAX_DELTA,
+	    sc, SYNAPTICS_SYSCTL_TAP_MAX_DELTA,
 	    synaptics_sysctl, "I",
 	    "Length of segments above which a tap is ignored");
 
@@ -4412,17 +5133,17 @@
 	SYSCTL_ADD_PROC(&sc->syninfo.sysctl_ctx,
 	    SYSCTL_CHILDREN(sc->syninfo.sysctl_tree), OID_AUTO,
 	    "tap_min_queue", CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
-	    &sc->syninfo.tap_min_queue, SYNAPTICS_SYSCTL_TAP_MIN_QUEUE,
+	    sc, SYNAPTICS_SYSCTL_TAP_MIN_QUEUE,
 	    synaptics_sysctl, "I",
 	    "Number of packets required to consider a tap");
 
 	/* hw.psm.synaptics.taphold_timeout. */
-	sc->synaction.in_taphold = 0;
+	sc->synaction[0].in_taphold = 0;
 	sc->syninfo.taphold_timeout = tap_timeout;
 	SYSCTL_ADD_PROC(&sc->syninfo.sysctl_ctx,
 	    SYSCTL_CHILDREN(sc->syninfo.sysctl_tree), OID_AUTO,
 	    "taphold_timeout", CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
-	    &sc->syninfo.taphold_timeout, SYNAPTICS_SYSCTL_TAPHOLD_TIMEOUT,
+	    sc, SYNAPTICS_SYSCTL_TAPHOLD_TIMEOUT,
 	    synaptics_sysctl, "I",
 	    "Maximum elapsed time between two taps to consider a tap-hold "
 	    "action");
@@ -4432,7 +5153,7 @@
 	SYSCTL_ADD_PROC(&sc->syninfo.sysctl_ctx,
 	    SYSCTL_CHILDREN(sc->syninfo.sysctl_tree), OID_AUTO,
 	    "vscroll_hor_area", CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
-	    &sc->syninfo.vscroll_hor_area, SYNAPTICS_SYSCTL_VSCROLL_HOR_AREA,
+	    sc, SYNAPTICS_SYSCTL_VSCROLL_HOR_AREA,
 	    synaptics_sysctl, "I",
 	    "Area reserved for horizontal virtual scrolling");
 
@@ -4441,7 +5162,7 @@
 	SYSCTL_ADD_PROC(&sc->syninfo.sysctl_ctx,
 	    SYSCTL_CHILDREN(sc->syninfo.sysctl_tree), OID_AUTO,
 	    "vscroll_ver_area", CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
-	    &sc->syninfo.vscroll_ver_area, SYNAPTICS_SYSCTL_VSCROLL_VER_AREA,
+	    sc, SYNAPTICS_SYSCTL_VSCROLL_VER_AREA,
 	    synaptics_sysctl, "I",
 	    "Area reserved for vertical virtual scrolling");
 
@@ -4450,8 +5171,7 @@
 	SYSCTL_ADD_PROC(&sc->syninfo.sysctl_ctx,
 	    SYSCTL_CHILDREN(sc->syninfo.sysctl_tree), OID_AUTO,
 	    "vscroll_min_delta", CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
-	    &sc->syninfo.vscroll_min_delta,
-	    SYNAPTICS_SYSCTL_VSCROLL_MIN_DELTA,
+	    sc, SYNAPTICS_SYSCTL_VSCROLL_MIN_DELTA,
 	    synaptics_sysctl, "I",
 	    "Minimum movement to consider virtual scrolling");
 
@@ -4460,7 +5180,7 @@
 	SYSCTL_ADD_PROC(&sc->syninfo.sysctl_ctx,
 	    SYSCTL_CHILDREN(sc->syninfo.sysctl_tree), OID_AUTO,
 	    "vscroll_div_min", CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
-	    &sc->syninfo.vscroll_div_min, SYNAPTICS_SYSCTL_VSCROLL_DIV_MIN,
+	    sc, SYNAPTICS_SYSCTL_VSCROLL_DIV_MIN,
 	    synaptics_sysctl, "I",
 	    "Divisor for fast scrolling");
 
@@ -4469,7 +5189,7 @@
 	SYSCTL_ADD_PROC(&sc->syninfo.sysctl_ctx,
 	    SYSCTL_CHILDREN(sc->syninfo.sysctl_tree), OID_AUTO,
 	    "vscroll_div_max", CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
-	    &sc->syninfo.vscroll_div_max, SYNAPTICS_SYSCTL_VSCROLL_DIV_MAX,
+	    sc, SYNAPTICS_SYSCTL_VSCROLL_DIV_MAX,
 	    synaptics_sysctl, "I",
 	    "Divisor for slow scrolling");
 
@@ -4478,14 +5198,107 @@
 	SYSCTL_ADD_PROC(&sc->syninfo.sysctl_ctx,
 	    SYSCTL_CHILDREN(sc->syninfo.sysctl_tree), OID_AUTO,
 	    "touchpad_off", CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
-	    &sc->syninfo.touchpad_off, SYNAPTICS_SYSCTL_TOUCHPAD_OFF,
+	    sc, SYNAPTICS_SYSCTL_TOUCHPAD_OFF,
 	    synaptics_sysctl, "I",
 	    "Turn off touchpad");
+
+	sc->syninfo.softbuttons = 0;
+	sc->syninfo.softbuttons_y = 0;
+	sc->syninfo.softbutton2_x = 0;
+	sc->syninfo.softbutton3_x = 0;
+	sc->syninfo.softbutton_nomove = 0;
+
+	/* skip softbuttons sysctl on not clickpads */
+	if (!sc->synhw.capClickPad)
+		return;
+
+	/* hw.psm.synaptics.softbuttons */
+	sc->syninfo.softbuttons = 3;
+	SYSCTL_ADD_PROC(&sc->syninfo.sysctl_ctx,
+	    SYSCTL_CHILDREN(sc->syninfo.sysctl_tree), OID_AUTO,
+	    "softbuttons", CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
+	    sc, SYNAPTICS_SYSCTL_SOFTBUTTONS,
+	    synaptics_sysctl, "I",
+	    "Enables top or bottom edges to be a softbuttons on clickpads");
+
+	/* hw.psm.synaptics.softbuttons_y */
+	sc->syninfo.softbuttons_y = sc->synhw.maximumYCoord / 4;
+	SYSCTL_ADD_PROC(&sc->syninfo.sysctl_ctx,
+	    SYSCTL_CHILDREN(sc->syninfo.sysctl_tree), OID_AUTO,
+	    "softbuttons_y", CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
+	    sc, SYNAPTICS_SYSCTL_SOFTBUTTONS_Y,
+	    synaptics_sysctl, "I",
+	    "Vertical size of softbuttons area");
+
+	/* hw.psm.synaptics.softbutton2_x */
+	sc->syninfo.softbutton2_x = sc->synhw.maximumXCoord / 3;
+	SYSCTL_ADD_PROC(&sc->syninfo.sysctl_ctx,
+	    SYSCTL_CHILDREN(sc->syninfo.sysctl_tree), OID_AUTO,
+	    "softbutton2_x", CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
+	    sc, SYNAPTICS_SYSCTL_SOFTBUTTON2_X,
+	    synaptics_sysctl, "I",
+	    "Horisontal position of 2-nd softbutton left edge (0-disable)");
+
+	/* hw.psm.synaptics.softbutton3_x */
+	sc->syninfo.softbutton3_x = sc->synhw.maximumXCoord * 2 / 3;
+	SYSCTL_ADD_PROC(&sc->syninfo.sysctl_ctx,
+	    SYSCTL_CHILDREN(sc->syninfo.sysctl_tree), OID_AUTO,
+	    "softbutton3_x", CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
+	    sc, SYNAPTICS_SYSCTL_SOFTBUTTON3_X,
+	    synaptics_sysctl, "I",
+	    "Horisontal position of 3-rd softbutton left edge (0-disable)");
+
+	/* hw.psm.synaptics.softbutton_nomove */
+	sc->syninfo.softbutton_nomove = 0;
+	SYSCTL_ADD_PROC(&sc->syninfo.sysctl_ctx,
+	    SYSCTL_CHILDREN(sc->syninfo.sysctl_tree), OID_AUTO,
+	    "softbutton_nomove", CTLTYPE_INT|CTLFLAG_RW|CTLFLAG_ANYBODY,
+	    sc, SYNAPTICS_SYSCTL_SOFTBUTTON_NOMOVE,
+	    synaptics_sysctl, "I",
+	    "Disable movement on the bottom edge area so it works as buttons");
 }
 
 static int
-enable_synaptics(KBDC kbdc, struct psm_softc *sc)
+synaptics_preferred_mode(struct psm_softc *sc) {
+	int mode_byte;
+
+	mode_byte = 0xc0;
+
+	/* request wmode where available */
+	if (sc->synhw.capExtended)
+		mode_byte |= 1;
+
+	/*
+	 * Disable gesture processing when native packets are requested. This
+	 * enables sending of encapsulated "extended W mode" packets.
+	 */
+	if (sc->mode.level == PSM_LEVEL_NATIVE)
+		mode_byte |= (1 << 2);
+
+	return mode_byte;
+}
+
+static void
+synaptics_set_mode(struct psm_softc *sc, int mode_byte) {
+	mouse_ext_command(sc->kbdc, mode_byte);
+
+	/* "Commit" the Set Mode Byte command sent above. */
+	set_mouse_sampling_rate(sc->kbdc, 20);
+
+	/*
+	 * Enable advanced gestures mode if supported and we are not entering
+	 * passthrough mode.
+	 */
+	if (sc->synhw.capAdvancedGestures && !(mode_byte & (1 << 5))) {
+		mouse_ext_command(sc->kbdc, 3);
+		set_mouse_sampling_rate(sc->kbdc, 0xc8);
+	}
+}
+
+static int
+enable_synaptics(struct psm_softc *sc, enum probearg arg)
 {
+	KBDC kbdc = sc->kbdc;
 	synapticshw_t synhw;
 	int status[3];
 	int buttons;
@@ -4566,14 +5379,28 @@
 	buttons = 0;
 	synhw.capExtended = (status[0] & 0x80) != 0;
 	if (synhw.capExtended) {
-		synhw.nExtendedQueries = (status[0] & 0x70) != 0;
+		synhw.nExtendedQueries = (status[0] & 0x70) >> 4;
 		synhw.capMiddle        = (status[0] & 0x04) != 0;
 		synhw.capPassthrough   = (status[2] & 0x80) != 0;
+		synhw.capLowPower      = (status[2] & 0x40) != 0;
+		synhw.capMultiFingerReport =
+					 (status[2] & 0x20) != 0;
 		synhw.capSleep         = (status[2] & 0x10) != 0;
 		synhw.capFourButtons   = (status[2] & 0x08) != 0;
+		synhw.capBallistics    = (status[2] & 0x04) != 0;
 		synhw.capMultiFinger   = (status[2] & 0x02) != 0;
 		synhw.capPalmDetect    = (status[2] & 0x01) != 0;
 
+		if (!set_mouse_scaling(kbdc, 1))
+			return (FALSE);
+		if (mouse_ext_command(kbdc, 0x08) == 0)
+			return (FALSE);
+		if (get_mouse_status(kbdc, status, 0, 3) != 3)
+			return (FALSE);
+
+		synhw.infoXupmm = status[0];
+		synhw.infoYupmm = status[2];
+
 		if (verbose >= 2) {
 			printf("  Extended capabilities:\n");
 			printf("   capExtended: %d\n", synhw.capExtended);
@@ -4581,10 +5408,16 @@
 			printf("   nExtendedQueries: %d\n",
 			    synhw.nExtendedQueries);
 			printf("   capPassthrough: %d\n", synhw.capPassthrough);
+			printf("   capLowPower: %d\n", synhw.capLowPower);
+			printf("   capMultiFingerReport: %d\n",
+			    synhw.capMultiFingerReport);
 			printf("   capSleep: %d\n", synhw.capSleep);
 			printf("   capFourButtons: %d\n", synhw.capFourButtons);
+			printf("   capBallistics: %d\n", synhw.capBallistics);
 			printf("   capMultiFinger: %d\n", synhw.capMultiFinger);
 			printf("   capPalmDetect: %d\n", synhw.capPalmDetect);
+			printf("   infoXupmm: %d\n", synhw.infoXupmm);
+			printf("   infoYupmm: %d\n", synhw.infoYupmm);
 		}
 
 		/*
@@ -4592,7 +5425,9 @@
 		 * supports this number of extended queries. We can load
 		 * more information about buttons using query 0x09.
 		 */
-		if (synhw.capExtended && synhw.nExtendedQueries) {
+		if (synhw.nExtendedQueries >= 1) {
+			if (!set_mouse_scaling(kbdc, 1))
+				return (FALSE);
 			if (mouse_ext_command(kbdc, 0x09) == 0)
 				return (FALSE);
 			if (get_mouse_status(kbdc, status, 0, 3) != 3)
@@ -4601,6 +5436,7 @@
 			synhw.horizontalScroll = (status[0] & 0x02) != 0;
 			synhw.verticalWheel    = (status[0] & 0x08) != 0;
 			synhw.nExtendedButtons = (status[1] & 0xf0) >> 4;
+			synhw.capEWmode        = (status[0] & 0x04) != 0;
 			if (verbose >= 2) {
 				printf("  Extended model ID:\n");
 				printf("   verticalScroll: %d\n",
@@ -4611,6 +5447,8 @@
 				    synhw.verticalWheel);
 				printf("   nExtendedButtons: %d\n",
 				    synhw.nExtendedButtons);
+				printf("   capEWmode: %d\n",
+				    synhw.capEWmode);
 			}
 			/*
 			 * Add the number of extended buttons to the total
@@ -4624,7 +5462,101 @@
 			 * add a fourth button to the total button count.
 			 */
 			buttons = synhw.capFourButtons ? 1 : 0;
+
+		/* Read the continued capabilities bits. */
+		if (synhw.nExtendedQueries >= 4) {
+			if (!set_mouse_scaling(kbdc, 1))
+				return (FALSE);
+			if (mouse_ext_command(kbdc, 0x0c) == 0)
+				return (FALSE);
+			if (get_mouse_status(kbdc, status, 0, 3) != 3)
+				return (FALSE);
+
+			synhw.capClickPad         = (status[1] & 0x01) << 1;
+			synhw.capClickPad        |= (status[0] & 0x10) != 0;
+			synhw.capDeluxeLEDs       = (status[1] & 0x02) != 0;
+			synhw.noAbsoluteFilter    = (status[1] & 0x04) != 0;
+			synhw.capReportsV         = (status[1] & 0x08) != 0;
+			synhw.capUniformClickPad  = (status[1] & 0x10) != 0;
+			synhw.capReportsMin       = (status[1] & 0x20) != 0;
+			synhw.capInterTouch       = (status[1] & 0x40) != 0;
+			synhw.capReportsMax       = (status[0] & 0x02) != 0;
+			synhw.capClearPad         = (status[0] & 0x04) != 0;
+			synhw.capAdvancedGestures = (status[0] & 0x08) != 0;
+			synhw.capCoveredPad       = (status[0] & 0x80) != 0;
+
+			if (synhw.capReportsMax) {
+				if (!set_mouse_scaling(kbdc, 1))
+					return (FALSE);
+				if (mouse_ext_command(kbdc, 0x0d) == 0)
+					return (FALSE);
+				if (get_mouse_status(kbdc, status, 0, 3) != 3)
+					return (FALSE);
+
+				synhw.maximumXCoord = (status[0] << 5) |
+						     ((status[1] & 0x0f) << 1);
+				synhw.maximumYCoord = (status[2] << 5) |
+						     ((status[1] & 0xf0) >> 3);
+			} else
+				synhw.maximumXCoord = synhw.maximumYCoord =
+				    6143;
+
+			if (synhw.capReportsMin) {
+				if (!set_mouse_scaling(kbdc, 1))
+					return (FALSE);
+				if (mouse_ext_command(kbdc, 0x0f) == 0)
+					return (FALSE);
+				if (get_mouse_status(kbdc, status, 0, 3) != 3)
+					return (FALSE);
+
+				synhw.minimumXCoord = (status[0] << 5) |
+						     ((status[1] & 0x0f) << 1);
+				synhw.minimumYCoord = (status[2] << 5) |
+						     ((status[1] & 0xf0) >> 3);
+			} else
+				synhw.minimumXCoord = synhw.minimumYCoord = 0;
+
+			if (verbose >= 2) {
+				printf("  Continued capabilities:\n");
+				printf("   capClickPad: %d\n",
+				       synhw.capClickPad);
+				printf("   capDeluxeLEDs: %d\n",
+				       synhw.capDeluxeLEDs);
+				printf("   noAbsoluteFilter: %d\n",
+				       synhw.noAbsoluteFilter);
+				printf("   capReportsV: %d\n",
+				       synhw.capReportsV);
+				printf("   capUniformClickPad: %d\n",
+				       synhw.capUniformClickPad);
+				printf("   capReportsMin: %d\n",
+				       synhw.capReportsMin);
+				printf("   capInterTouch: %d\n",
+				       synhw.capInterTouch);
+				printf("   capReportsMax: %d\n",
+				       synhw.capReportsMax);
+				printf("   capClearPad: %d\n",
+				       synhw.capClearPad);
+				printf("   capAdvancedGestures: %d\n",
+				       synhw.capAdvancedGestures);
+				printf("   capCoveredPad: %d\n",
+				       synhw.capCoveredPad);
+				if (synhw.capReportsMax) {
+					printf("   maximumXCoord: %d\n",
+					       synhw.maximumXCoord);
+					printf("   maximumYCoord: %d\n",
+					       synhw.maximumYCoord);
+				}
+				if (synhw.capReportsMin) {
+					printf("   minimumXCoord: %d\n",
+					       synhw.minimumXCoord);
+					printf("   minimumYCoord: %d\n",
+					       synhw.minimumYCoord);
+				}
+			}
+			buttons += synhw.capClickPad;
+		}
 	}
+
 	if (verbose >= 2) {
 		if (synhw.capExtended)
 			printf("  Additional Buttons: %d\n", buttons);
@@ -4632,42 +5564,6 @@
 			printf("  No extended capabilities\n");
 	}
 
-	/* Read the continued capabilities bits. */
-	if (mouse_ext_command(kbdc, 0xc) != 0 &&
-	    get_mouse_status(kbdc, status, 0, 3) == 3) {
-		synhw.capClickPad         = (status[1] & 0x01) << 1;
-		synhw.capClickPad        |= (status[0] & 0x10) != 0;
-		synhw.capDeluxeLEDs       = (status[1] & 0x02) != 0;
-		synhw.noAbsoluteFilter    = (status[1] & 0x04) != 0;
-		synhw.capReportsV         = (status[1] & 0x08) != 0;
-		synhw.capUniformClickPad  = (status[1] & 0x10) != 0;
-		synhw.capReportsMin       = (status[1] & 0x20) != 0;
-		synhw.capInterTouch       = (status[1] & 0x40) != 0;
-		synhw.capReportsMax       = (status[2] & 0x02) != 0;
-		synhw.capClearPad         = (status[2] & 0x04) != 0;
-		synhw.capAdvancedGestures = (status[2] & 0x08) != 0;
-		synhw.capCoveredPad       = (status[2] & 0x80) != 0;
-
-		if (verbose >= 2) {
-			printf("  Continued capabilities:\n");
-			printf("   capClickPad: %d\n", synhw.capClickPad);
-			printf("   capDeluxeLEDs: %d\n", synhw.capDeluxeLEDs);
-			printf("   noAbsoluteFilter: %d\n",
-			    synhw.noAbsoluteFilter);
-			printf("   capReportsV: %d\n", synhw.capReportsV);
-			printf("   capUniformClickPad: %d\n",
-			    synhw.capUniformClickPad);
-			printf("   capReportsMin: %d\n", synhw.capReportsMin);
-			printf("   capInterTouch: %d\n", synhw.capInterTouch);
-			printf("   capReportsMax: %d\n", synhw.capReportsMax);
-			printf("   capClearPad: %d\n", synhw.capClearPad);
-			printf("   capAdvancedGestures: %d\n",
-			    synhw.capAdvancedGestures);
-			printf("   capCoveredPad: %d\n", synhw.capCoveredPad);
-		}
-		buttons += synhw.capClickPad;
-	}
-
 	/*
 	 * Add the default number of 3 buttons to the total
 	 * count of supported buttons reported above.
@@ -4690,27 +5586,23 @@
 		return (FALSE);
 	}
 
-	if (sc != NULL)
+	if (arg == PROBE)
 		sc->synhw = synhw;
 	if (!synaptics_support)
 		return (FALSE);
 
-	/* Set the mode byte; request wmode where available. */
-	mouse_ext_command(kbdc, synhw.capExtended ? 0xc1 : 0xc0);
+	synaptics_set_mode(sc, synaptics_preferred_mode(sc));
 
-	/* "Commit" the Set Mode Byte command sent above. */
-	set_mouse_sampling_rate(kbdc, 20);
+	if (trackpoint_support && synhw.capPassthrough) {
+		enable_trackpoint(sc, arg);
+	}
 
 	VLOG(3, (LOG_DEBUG, "synaptics: END init (%d buttons)\n", buttons));
 
-	if (sc != NULL) {
-		if (trackpoint_support && synhw.capPassthrough) {
-			synaptics_passthrough_on(sc);
-			enable_trackpoint(kbdc, sc);
-			synaptics_passthrough_off(sc);
-		}
+	if (arg == PROBE) {
 		/* Create sysctl tree. */
-		synaptics_sysctl_create_tree(sc);
+		synaptics_sysctl_create_tree(sc, "synaptics",
+		    "Synaptics TouchPad");
 		sc->hw.buttons = buttons;
 	}
 
@@ -4720,30 +5612,17 @@
 static void
 synaptics_passthrough_on(struct psm_softc *sc)
 {
-	int mode_byte;
-
-	mode_byte = 0xc1 | (1 << 5);
-	VLOG(2, (LOG_NOTICE, "psm: setting pass-through mode. %d\n",
-		mode_byte));
-	mouse_ext_command(sc->kbdc, mode_byte);
-
-	/* "Commit" the Set Mode Byte command sent above. */
-	set_mouse_sampling_rate(sc->kbdc, 20);
+	VLOG(2, (LOG_NOTICE, "psm: setting pass-through mode.\n"));
+	synaptics_set_mode(sc, synaptics_preferred_mode(sc) | (1 << 5));
 }
 
 static void
 synaptics_passthrough_off(struct psm_softc *sc)
 {
-	int mode_byte;
-
-	mode_byte = 0xc1;
 	VLOG(2, (LOG_NOTICE, "psm: turning pass-through mode off.\n"));
 	set_mouse_scaling(sc->kbdc, 2);
 	set_mouse_scaling(sc->kbdc, 1);
-	mouse_ext_command(sc->kbdc, mode_byte);
-
-	/* "Commit" the Set Mode Byte command sent above. */
-	set_mouse_sampling_rate(sc->kbdc, 20);
+	synaptics_set_mode(sc, synaptics_preferred_mode(sc));
 }
 
 /* IBM/Lenovo TrackPoint */
@@ -4966,25 +5845,37 @@
 }
 
 static int
-enable_trackpoint(KBDC kbdc, struct psm_softc *sc)
+enable_trackpoint(struct psm_softc *sc, enum probearg arg)
 {
+	KBDC kbdc = sc->kbdc;
 	int id;
 
+	/*
+	 * If called from enable_synaptics(), make sure that passthrough
+	 * mode is enabled so we can reach the trackpoint.
+	 * However, passthrough mode must be disabled before setting the
+	 * trackpoint parameters, as rackpoint_command() enables and disables
+	 * passthrough mode on its own.
+	 */
+	if (sc->synhw.capPassthrough)
+		synaptics_passthrough_on(sc);
+
 	if (send_aux_command(kbdc, 0xe1) != PSM_ACK ||
 	    read_aux_data(kbdc) != 0x01)
-		return (FALSE);
+		goto no_trackpoint;
 	id = read_aux_data(kbdc);
 	if (id < 0x01)
-		return (FALSE);
-	if (sc != NULL)
+		goto no_trackpoint;
+	if (arg == PROBE)
 		sc->tphw = id;
 	if (!trackpoint_support)
-		return (FALSE);
+		goto no_trackpoint;
 
-	if (sc != NULL) {
-		/* Create sysctl tree. */
+	if (sc->synhw.capPassthrough)
+		synaptics_passthrough_off(sc);
+
+	if (arg == PROBE) {
 		trackpoint_sysctl_create_tree(sc);
-
 		/*
 		 * Don't overwrite hwid and buttons when we are
 		 * a guest device.
@@ -4995,13 +5886,22 @@
 		}
 	}
 
+	set_trackpoint_parameters(sc);
+
 	return (TRUE);
+
+no_trackpoint:
+	if (sc->synhw.capPassthrough)
+		synaptics_passthrough_off(sc);
+
+	return (FALSE);
 }
 
 /* Interlink electronics VersaPad */
 static int
-enable_versapad(KBDC kbdc, struct psm_softc *sc)
+enable_versapad(struct psm_softc *sc, enum probearg arg)
 {
+	KBDC kbdc = sc->kbdc;
 	int data[3];
 
 	set_mouse_resolution(kbdc, PSMD_RES_MEDIUM_HIGH); /* set res. 2 */
@@ -5019,6 +5919,326 @@
 	return (TRUE);				/* PS/2 absolute mode */
 }
 
+/* Elantech Touchpad */
+static int
+elantech_read_1(KBDC kbdc, int hwversion, int reg, int *val)
+{
+	int res, readcmd, retidx;
+	int resp[3];
+
+	readcmd = hwversion == 2 ? ELANTECH_REG_READ : ELANTECH_REG_RDWR;
+	retidx = hwversion == 4 ? 1 : 0;
+
+	res = send_aux_command(kbdc, ELANTECH_CUSTOM_CMD) != PSM_ACK;
+	res |= send_aux_command(kbdc, readcmd) != PSM_ACK;
+	res |= send_aux_command(kbdc, ELANTECH_CUSTOM_CMD) != PSM_ACK;
+	res |= send_aux_command(kbdc, reg) != PSM_ACK;
+	res |= get_mouse_status(kbdc, resp, 0, 3) != 3;
+
+	if (res == 0)
+		*val = resp[retidx];
+
+	return (res);
+}
+
+static int
+elantech_write_1(KBDC kbdc, int hwversion, int reg, int val)
+{
+	int res, writecmd;
+
+	writecmd = hwversion == 2 ? ELANTECH_REG_WRITE : ELANTECH_REG_RDWR;
+
+	res = send_aux_command(kbdc, ELANTECH_CUSTOM_CMD) != PSM_ACK;
+	res |= send_aux_command(kbdc, writecmd) != PSM_ACK;
+	res |= send_aux_command(kbdc, ELANTECH_CUSTOM_CMD) != PSM_ACK;
+	res |= send_aux_command(kbdc, reg) != PSM_ACK;
+	if (hwversion == 4) {
+		res |= send_aux_command(kbdc, ELANTECH_CUSTOM_CMD) != PSM_ACK;
+		res |= send_aux_command(kbdc, writecmd) != PSM_ACK;
+	}
+	res |= send_aux_command(kbdc, ELANTECH_CUSTOM_CMD) != PSM_ACK;
+	res |= send_aux_command(kbdc, val) != PSM_ACK;
+	res |= set_mouse_scaling(kbdc, 1) == 0;
+
+	return (res);
+}
+
+static int
+elantech_cmd(KBDC kbdc, int hwversion, int cmd, int *resp)
+{
+	int res;
+
+	if (hwversion == 2) {
+		res = set_mouse_scaling(kbdc, 1) == 0;
+		res |= mouse_ext_command(kbdc, cmd) == 0;
+	} else {
+		res = send_aux_command(kbdc, ELANTECH_CUSTOM_CMD) != PSM_ACK;
+		res |= send_aux_command(kbdc, cmd) != PSM_ACK;
+	}
+	res |= get_mouse_status(kbdc, resp, 0, 3) != 3;
+
+	return (res);
+}
+
+static int
+elantech_init(KBDC kbdc, elantechhw_t *elanhw)
+{
+	int i, val, res, hwversion, reg10;
+
+	/* set absolute mode */
+	hwversion = elanhw->hwversion;
+	reg10 = -1;
+	switch (hwversion) {
+	case 2:
+		reg10 = elanhw->fwversion == 0x020030 ? 0x54 : 0xc4;
+		res = elantech_write_1(kbdc, hwversion, 0x10, reg10);
+		if (res)
+			break;
+		res = elantech_write_1(kbdc, hwversion, 0x11, 0x8A);
+		break;
+	case 3:
+		reg10 = 0x0b;
+		res = elantech_write_1(kbdc, hwversion, 0x10, reg10);
+		break;
+	case 4:
+		res = elantech_write_1(kbdc, hwversion, 0x07, 0x01);
+		break;
+	default:
+		res = 1;
+	}
+
+	/* Read back reg 0x10 to ensure hardware is ready. */
+	if (res == 0 && reg10 >= 0) {
+		for (i = 0; i < 5; i++) {
+			if (elantech_read_1(kbdc, hwversion, 0x10, &val) == 0)
+				break;
+			pause("elan", 1);
+		}
+		if (i == 5)
+			res = 1;
+	}
+
+	if (res)
+		printf("couldn't set absolute mode\n");
+
+	return (res);
+}
+
+static void
+elantech_init_synaptics(struct psm_softc *sc)
+{
+
+	/* Set capabilites required by movement smother */
+	sc->synhw.infoMajor = sc->elanhw.hwversion;
+	sc->synhw.infoMinor = sc->elanhw.fwversion;
+	sc->synhw.infoXupmm = (sc->elanhw.dpix * 10 + 5) / 254;
+	sc->synhw.infoYupmm = (sc->elanhw.dpiy * 10 + 5) / 254;
+	sc->synhw.verticalScroll = 0;
+	sc->synhw.nExtendedQueries = 4;
+	sc->synhw.capExtended = 1;
+	sc->synhw.capPassthrough = sc->elanhw.hastrackpad;
+	sc->synhw.capClickPad = sc->elanhw.isclickpad;
+	sc->synhw.capMultiFinger = 1;
+	sc->synhw.capPalmDetect = 1;
+	sc->synhw.capPen = 0;
+	sc->synhw.capReportsMax = 1;
+	sc->synhw.maximumXCoord = sc->elanhw.sizex;
+	sc->synhw.maximumYCoord = sc->elanhw.sizey;
+	sc->synhw.capReportsMin = 1;
+	sc->synhw.minimumXCoord = 0;
+	sc->synhw.minimumYCoord = 0;
+
+	if (sc->syninfo.sysctl_tree == NULL) {
+		synaptics_sysctl_create_tree(sc, "elantech",
+		    "Elantech Touchpad");
+
+		/*
+		 * Adjust synaptic smoother tunables
+		 * 1. Disable finger detection pressure threshold. Unlike
+		 *    synaptics we assume the finger is acting when packet with
+		 *    its X&Y arrives not when pressure exceedes some threshold
+		 * 2. Disable unrelated features like margins and noisy areas
+		 * 3. Disable virtual scroll areas as 2nd finger is preferable
+		 * 4. Scale down divisors and movement lengths by a factor of 3
+		 *    where 3 is Synaptics to Elantech (~2200/800) dpi ratio
+		 */
+
+		/* Disable finger detection pressure threshold */
+		sc->syninfo.min_pressure = 1;
+
+		/* Use full area of touchpad */
+		sc->syninfo.margin_top = 0;
+		sc->syninfo.margin_right = 0;
+		sc->syninfo.margin_bottom = 0;
+		sc->syninfo.margin_left = 0;
+		/* Disable noisy area */
+		sc->syninfo.na_top = 0;
+		sc->syninfo.na_right = 0;
+		sc->syninfo.na_bottom = 0;
+		sc->syninfo.na_left = 0;
+
+		/* tune divisors and movement lengths */
+		sc->syninfo.weight_len_squared = 200;
+		sc->syninfo.div_min = 3;
+		sc->syninfo.div_max = 6;
+		sc->syninfo.div_max_na = 10;
+		sc->syninfo.div_len = 30;
+		sc->syninfo.tap_max_delta = 25;
+
+		/* disable virtual scrolling areas and tune its divisors */
+		sc->syninfo.vscroll_hor_area = 0;
+		sc->syninfo.vscroll_ver_area = 0;
+		sc->syninfo.vscroll_min_delta = 15;
+		sc->syninfo.vscroll_div_min = 30;
+		sc->syninfo.vscroll_div_max = 50;
+	}
+
+	return;
+}
+
+static int
+enable_elantech(struct psm_softc *sc, enum probearg arg)
+{
+	static const int ic2hw[] =
+	/*IC: 0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f */
+	    { 0, 0, 2, 0, 2, 3, 4, 4, 4, 4, 4, 0, 0, 4, 4, 0 };
+	elantechhw_t elanhw;
+	int icversion, hwversion, dptracex, dptracey, id, resp[3];
+	KBDC kbdc = sc->kbdc;
+
+	VLOG(3, (LOG_DEBUG, "elantech: BEGIN init\n"));
+
+	set_mouse_scaling(kbdc, 1);
+	set_mouse_scaling(kbdc, 1);
+	set_mouse_scaling(kbdc, 1);
+	if (get_mouse_status(kbdc, resp, 0, 3) != 3)
+		return (FALSE);
+
+	if (!ELANTECH_MAGIC(resp))
+		return (FALSE);
+
+	/* Identify the Touchpad version. */
+	if (elantech_cmd(kbdc, 2, ELANTECH_FW_VERSION, resp))
+		return (FALSE);
+
+	bzero(&elanhw, sizeof(elanhw));
+
+	elanhw.fwversion = (resp[0] << 16) | (resp[1] << 8) | resp[2];
+	icversion = resp[0] & 0x0f;
+	hwversion = ic2hw[icversion];
+
+	if (verbose >= 2)
+		printf("Elantech touchpad hardware v.%d firmware v.0x%06x\n",
+		    hwversion, elanhw.fwversion);
+
+	if (ELANTECH_HW_IS_V1(elanhw.fwversion)) {
+		printf ("  Unsupported touchpad hardware (v1)\n");
+		return (FALSE);
+	}
+	if (hwversion == 0) {
+		printf ("  Unknown touchpad hardware (firmware v.0x%06x)\n",
+		    elanhw.fwversion);
+		return (FALSE);
+	}
+
+	/* Get the Touchpad model information. */
+	elanhw.hwversion = hwversion;
+	elanhw.isclickpad = (resp[1] & 0x10) != 0;
+	elanhw.hascrc = (resp[1] & 0x40) != 0;
+	elanhw.haspressure = elanhw.fwversion >= 0x020800;
+
+	/* Read the capability bits. */
+	if (elantech_cmd(kbdc, hwversion, ELANTECH_CAPABILITIES, resp) != 0) {
+		printf("  Failed to read capability bits\n");
+		return (FALSE);
+	}
+
+	elanhw.ntracesx = resp[1] - 1;
+	elanhw.ntracesy = resp[2] - 1;
+	elanhw.hastrackpad = (resp[0] & 0x80) != 0;
+
+	/* Get the touchpad resolution */
+	switch (hwversion) {
+	case 2:
+		elanhw.dpix = elanhw.dpiy = 400;
+		break;
+	case 4:
+		if (elantech_cmd(kbdc, hwversion, ELANTECH_RESOLUTION, resp)
+		    == 0) {
+			elanhw.dpix = (resp[1] & 0x0f) * 10 + 790;
+			elanhw.dpiy = ((resp[1] & 0xf0) >> 4) * 10 + 790;
+			break;
+		}
+		/* FALLTHROUGH */
+	case 3:
+		elanhw.dpix = elanhw.dpiy = 800;
+		break;
+	}
+
+	if (!elantech_support)
+		return (FALSE);
+
+	if (elantech_init(kbdc, &elanhw)) {
+		printf("couldn't initialize elantech touchpad\n");
+		return (FALSE);
+	}
+
+	/*
+	 * Get the touchpad reporting range.
+	 * On HW v.3 touchpads it should be done after switching hardware
+	 * to real resolution mode (by setting bit 3 of reg10)
+	 */
+	if (elantech_cmd(kbdc, hwversion, ELANTECH_FW_ID, resp) != 0) {
+		printf("  Failed to read touchpad size\n");
+		elanhw.sizex = 10000; /* Arbitrary high values to     */
+		elanhw.sizey = 10000; /* prevent clipping in smoother */
+	} else if (hwversion == 2) {
+		dptracex = dptracey = 64;
+		if ((elanhw.fwversion >> 16) == 0x14 && (resp[1] & 0x10) &&
+		    !elantech_cmd(kbdc, hwversion, ELANTECH_SAMPLE, resp)) {
+			dptracex = resp[1] / 2;
+			dptracey = resp[2] / 2;
+		}
+		elanhw.sizex = (elanhw.ntracesx - 1) * dptracex;
+		elanhw.sizey = (elanhw.ntracesy - 1) * dptracey;
+	} else {
+		elanhw.sizex = (resp[0] & 0x0f) << 8 | resp[1];
+		elanhw.sizey = (resp[0] & 0xf0) << 4 | resp[2];
+	}
+
+	if (verbose >= 2) {
+		printf("  Model information:\n");
+		printf("   MaxX:     %d\n", elanhw.sizex);
+		printf("   MaxY:     %d\n", elanhw.sizey);
+		printf("   DpiX:     %d\n", elanhw.dpix);
+		printf("   DpiY:     %d\n", elanhw.dpiy);
+		printf("   TracesX:  %d\n", elanhw.ntracesx);
+		printf("   TracesY:  %d\n", elanhw.ntracesy);
+		printf("   Clickpad: %d\n", elanhw.isclickpad);
+		printf("   Trackpad: %d\n", elanhw.hastrackpad);
+		printf("   CRC:      %d\n", elanhw.hascrc);
+		printf("   Pressure: %d\n", elanhw.haspressure);
+	}
+
+	VLOG(3, (LOG_DEBUG, "elantech: END init\n"));
+
+	if (arg == PROBE) {
+		sc->elanhw = elanhw;
+		sc->hw.buttons = 3;
+
+		/* Initialize synaptics movement smoother */
+		elantech_init_synaptics(sc);
+
+		for (id = 0; id < PSM_GESTURE_FINGERS; id++)
+			PSM_FINGER_RESET(sc->elanaction.fingers[id]);
+
+		if (elanhw.hascrc)
+			sc->config |= PSM_CONFIG_NOCHECKSYNC;
+	}
+
+	return (TRUE);
+}
+
 /*
  * Return true if 'now' is earlier than (start + (secs.usecs)).
  * Now may be NULL and the function will fetch the current time from
Index: sys/sys/mouse.h
===================================================================
--- sys/sys/mouse.h	(revision 292841)
+++ sys/sys/mouse.h	(working copy)
@@ -108,6 +108,9 @@
 	int capPalmDetect;
 	int capPassthrough;
 	int capMiddle;
+	int capLowPower;
+	int capMultiFingerReport;
+	int capBallistics;
 	int nExtendedButtons;
 	int nExtendedQueries;
 	int capClickPad;
@@ -125,6 +128,13 @@
 	int verticalScroll;
 	int horizontalScroll;
 	int verticalWheel;
+	int capEWmode;
+	int minimumXCoord;
+	int minimumYCoord;
+	int maximumXCoord;
+	int maximumYCoord;
+	int infoXupmm;
+	int infoYupmm;
 } synapticshw_t;
 
 /* iftype */
@@ -160,6 +170,7 @@
 #define MOUSE_MODEL_4DPLUS		12
 #define MOUSE_MODEL_SYNAPTICS		13
 #define	MOUSE_MODEL_TRACKPOINT		14
+#define MOUSE_MODEL_ELANTECH		15
 
 typedef struct mousemode {
 	int protocol;		/* MOUSE_PROTO_XXX */
@@ -230,6 +241,9 @@
 /* Synaptics Touchpad */
 #define MOUSE_SYNAPTICS_PACKETSIZE	6	/* '3' works better */
 
+/* Elantech Touchpad */
+#define MOUSE_ELANTECH_PACKETSIZE	6
+
 /* Microsoft Serial mouse data packet */
 #define MOUSE_MSS_PACKETSIZE	3
 #define MOUSE_MSS_SYNCMASK	0x40
Index: usr.sbin/moused/moused.c
===================================================================
--- usr.sbin/moused/moused.c	(revision 292841)
+++ usr.sbin/moused/moused.c	(working copy)
@@ -246,6 +246,7 @@
     { "4D+ Mouse",		MOUSE_MODEL_4DPLUS,		0 },
     { "Synaptics Touchpad",	MOUSE_MODEL_SYNAPTICS,		0 },
     { "TrackPoint",		MOUSE_MODEL_TRACKPOINT,		0 },
+    { "Elantech Touchpad",	MOUSE_MODEL_ELANTECH,		0 },
     { "generic",		MOUSE_MODEL_GENERIC,		0 },
     { NULL,			MOUSE_MODEL_UNKNOWN,		0 },
 };